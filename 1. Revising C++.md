---
date created: 2025-01-12 00:22
---

##### 1. Revising C++, references, pointers, stack segment and heap segment, operators new/delete, functions, function overloading and default parameters, passing variables by value and by reference/const reference, l-value vs r-value.

## 1. References and pointers

| **`*` (Указатели)**                                                     | **`&` (Ссылки и адреса)**                                                       |
| ----------------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| `int *x;`                                                               | `int &x = y;`                                                                   |
| Указатель хранит адрес переменной.                                      | Ссылка — это альтернативное имя для существующей переменной.                    |
| Можно переназначить на другой адрес.                                    | После инициализации всегда ссылается на одну и ту же переменную.                |
| Может быть `nullptr` (не указывает ни на что).                          | Не может быть `nullptr`, должна быть инициализирована сразу.                    |
| Доступ к значению через разыменование: `*x`.                            | Доступ к значению как к обычной переменной.                                     |
| Указатель можно менять: `x = &y;`                                       | Ссылку нельзя переназначить после инициализации.                                |
| Требует явного освобождения памяти при `new`.                           | Не требует управления памятью (работает с существующей переменной).             |
| Можно создавать массивы указателей.                                     | Ссылки на массивы не существуют, но можно передать массив по ссылке.            |
| Может быть многоуровневым: `int **ptr`.                                 | Ссылки всегда одноступенчатые.                                                  |
| Может быть использован для реализации динамической памяти.              | Используется для упрощенного доступа к переменной, без дополнительных операций. |

*примеры*:
```cpp
int x = 5;     // Объявление переменной x и инициализация значением 5
int& y = x;    // Ссылка y на переменную x

int* ptr = &x; // Указатель ptr, указывающий на адрес переменной x
```

```
+---------+         +---------+
|   x, y  | ----->  |    5    |  // Значение 5
+---------+         +---------+
      ^
      |
+---------+
|   ptr   | ----->  // Хранит адрес x
+---------+
```

**Ссылка**: Это алиас (другое имя) для переменной. Ссылка должна быть инициализирована и не может быть null.

```cpp
int x = 5; 
int& ref = x; // ref — это ссылка на x
```

**Указатель**: Переменная, которая хранит адрес памяти другой переменной.

```cpp
int x = 10;
int* ptr = &x; // ptr stores the address of x
*ptr; // Dereferencing
ptr = nullptr; // Null pointer
```

```cpp
void f(int* &p) { // Используем &, чтобы передать ptr в функцию по ссылке, p станет другим именем для ptr
	p = new int{5}; // В heap создается участок памяти типа int со значением 5, После возврата из функции p исчезнет, но ptr в main останется
}
int main() {
	int* ptr;
	f(ptr);
	
	std::cout << *ptr; // 5
	
	delete ptr; // После вызова f, ptr указывает на динамически выделенную память. Её нужно освободить
	return 0;
}
```

- если создать переменную и писать `*` слева от имени переменной - это **указатель**.
- если создать переменную и слева писать `&` - это **ссылка**.
- если переменная УЖЕ создана и писать `*` слева от имени переменной - это **dereference**.
- переменная УЖЕ создана и слева писать `&` - это **адрес** данной переменной.

```cpp
// если переменная уже объявлена
int* x = new int{5};

std::cout << *x;  // dereference (обращение к куску памяти, на который ссылается, указывает переменная)
```

```cpp
int y = 10;
int* x = &y; // так как * стоит при создании переменной - это указатель  так как y уже создан, то & - это не референс, а адрес то есть х есть указатель на у
```

##### Что МОЖНО делать?

```cpp
void f(int* &p) { // Используем &, чтобы передать ptr в функцию по ссылке, p станет другим именем для ptr
	p = new int{5}; // В heap создается участок памяти типа int со значением 5, После
	возврата из функции p исчезнет, но ptr в main останется
}
int main() {
	int* ptr;
	f(ptr);
	
	std::cout << *ptr; // 5
	
	delete ptr; // После вызова f, ptr указывает на динамически выделенную память. Её нужно освободить
	return 0;
}
```

##### Что НЕЛЬЗЯ делать?

```cpp
void f(int* &p) {
	*p = 5 // т.к p - это другое имя для ptr и мы не знаем на какой адрес ptr указывало (а этот кусок памяти может вообще быть не из нашей программы), то так писать НЕЛЬЗЯ
}
int main() {
	int* ptr; // ptr - это указатель, но мы не знаем на какой кусок памяти он указывает
	f(ptr);
}

void f(int* &p) {
	int x = 5;
	p = &x;
}
// если так написать, то после возвращения из функции переменная х удалится и это может привести к undefined behavior
```

## 2. Сегменты памяти: Stack и Heap

- **Стековая память (Stack)**: Автоматически выделяется и освобождается. Используется для локальных переменных и вызовов функций.
- **Куча (Heap)**: Память выделяется динамически с помощью `new` и освобождается с помощью `delete`.
  ```cpp
  int* p = new int(10); // Память выделяется в куче
  delete p;             // Память освобождается
  ```

## 3. Function Overloading

когда несколько функций имеют одинаковое имя, но различное число или тип аргументов.

**Example:**

```cpp
int add(int a, int b);          // Function that adds two integers

double add(double a, double b); // Function that adds two doubles

int min(int a, int b) {
	return a < b ? a : b;       // тернарный оператор
}

int min(int a, int b, int c){
	return min(min(a,b), c);
}

double min(double a, double b){
	return a < b ? a : b;
}
```

_**ВАЖНО:**_

- НО нельзя проводить перегрузку функций, которые отличаются лишь возвращаемым типом.
  ```cpp
  int func(int a);
  double func(int a); // Ошибка
  ```

_**ВОПРОС**_:
Mогут ли быть две функции с одинаковым названием, с одинаковым числом аргументов, с одинаковым типом аргументов, но с различными возвращаемыми типами?

_**ответ:**_
могут, но _только_ в определённых случаях,
_например_:

- **Могут быть 2 функции в одном и том же классе с тем же именем и аргументами, но один const, другой нет.**

```cpp
#include <iostream>
#include <string>

class Example {
private:
    std::string data;

public:
    Example(const std::string& str) : data(str) {}

    // Версия функции getData для неконстантных объектов
    std::string& getData() {
        std::cout << "Non-const getData called\n";
        return data; // Возвращает ссылку, чтобы можно было модифицировать
    }

    // Версия функции getData для константных объектов
    const std::string& getData() const {
        std::cout << "Const getData called\n";
        return data; // Возвращает const-ссылку, чтобы избежать модификации
    }
};

int main() {
    Example ex("Hello, World!");
    // Неконстантный объект вызывает неконстантную версию getData
    std::string& nonConstData = ex.getData();
    nonConstData += " Modified!";
    std::cout << nonConstData << std::endl; // Вывод: Hello, World! Modified!

    // Константный объект вызывает константную версию getData
    const Example constEx("Read-Only Data");
    const std::string& constData = constEx.getData();
    std::cout << constData << std::endl; // Вывод: Read-Only Data

    return 0;
}

```

- **Ковариантные типы возврата в виртуальных функциях**:
  ```cpp
  class Base {
  public:
  	virtual Base* clone() const;
  };

  class Derived : public Base {
  public:
  	Derived* clone() const override; // Разный возвращаемый тип
  };
  ```

- **Шаблонные функции и специализации**:
  ```cpp
  template <typename T>
  void bar(T t);

  template<>
  void bar<int>(int x); // Специализация
  ```

- **Разные пространства имен**:
  ```cpp
  namespace A { void func(int); }
  namespace B { double func(int); }
  ```

## 4. Параметры по умолчанию (Default parameters)

Параметры по умолчанию задаются при объявлении функции. Если аргумент не указан, используется значение по умолчанию.

_Пример:_

```cpp
void greet(const std::string& name = "Guest") {
    std::cout << "Hello, " << name << "!\n";
}

int main() {
    greet();        // Hello, Guest!
    greet("John");  // Hello, John!
    return 0;
}
```

_Example of Conflict:_

```cpp
void print(int x, int y = 10); // Function with default parameter
void print(int x);            // Overloaded function

int main() {
    print(5); // Error: Ambiguity, compiler cannot decide which version to call
    return 0;
}
```

**Случай с Base/Derived**

```cpp
struct Base {
    virtual void f(int x = 1) {
        std::cout << "Base: " << x << '\n';
    }
};

struct Derived : Base {
    void f(int x = 2) override {
        std::cout << "Derived: " << x << '\n';
    }
};

int main() {
    Base* obj = new Derived;
    obj->f(); // Derived: 1
    delete obj;
}
```

Потому что дефолт параметры компилятор подставляет во время компиляции, а выбирается какая функция вызовится на рантайме с помощью `vtable` .

## 5.1 Передача переменных по значению

Передача переменных **по значению** означает, что вызываемая функция получает **копию** аргумента. Изменения, сделанные с копией, не влияют на оригинальную переменную.

- Внутри функции создаётся новый объект, являющийся копией переданного аргумента.
- После выхода из функции этот объект удаляется.

Пример:

```cpp
void increment(int x) {
    x++; // изменяем копию, оригинал не меняется
}
```

1. **Безопасно**, так как функция работает с копией, а оригинал остаётся неизменным.
2. Подходит для простых типов данных (например, `int`, `float`), где копирование не занимает много памяти/времени.
3. Не рекомендуется для сложных объектов (например, `std::vector, std::string`), так как копирование может быть дорогим по ресурсам.

## 5.2 Передача переменных по ссылке

Передача **по ссылке** означает, что функция получает **ссылку на оригинальный объект**. Изменения, сделанные внутри функции, влияют на оригинальную переменную.

- Вместо копии передаётся ссылка на объект в памяти.
- Функция работает с этим объектом напрямую.

Пример:

```cpp
void increment(int& x) { // Ссылка на переменную
    x++; // изменяем оригинал
}
```

1. Позволяет функции изменять переданный объект.
2. Эффективно для передачи сложных объектов, так как не происходит копирования.
3. Следует использовать, если нужно модифицировать оригинальные данные.

## 5.3 Передача переменных по константной ссылке

Передача **по константной ссылке** позволяет функции принимать ссылку на объект **без возможности изменения его содержимого**.

- Функция получает ссылку, но компилятор гарантирует, что объект не будет изменён внутри функции.
- Используется для защиты данных от случайных изменений.

Пример:

```cpp
void print(const int& x) { // Константная ссылка
    std::cout << x << std::endl; // Только чтение, изменения запрещены
}
```

1. Используется, если нужно передавать большие объекты, не копируя их, но при этом гарантировать их неизменность.
2. Эффективна для передачи сложных типов данных, например:
   `void display(const std::vector<int>& vec);`
3. Безопасна, так как объект остаётся неизменным.

## 5.4 Сравнение методов передачи

| Способ передачи           | Изменяет оригинал | Использует копию | Эффективность                 | Применение              |
| ------------------------- | ----------------- | ---------------- | ----------------------------- | ----------------------- |
| **По значению**           | Нет               | Да               | Медленно для больших объектов | Простые типы данных     |
| **По ссылке**             | Да                | Нет              | Быстро                        | Модификация оригинала   |
| **По константной ссылке** | Нет               | Нет              | Быстро                        | Чтение больших объектов |

## 5.5 Особые случаи передачи

1. **Передача массивов:**
   - Массивы передаются **по ссылке по умолчанию**. Это означает, что изменения в массиве внутри функции повлияют на оригинал.
   `void modifyArray(int arr[], int size);`

2. **Передача указателей:**
   - Указатели передаются **по значению**, но они указывают на оригинальный объект.
   `void modifyPointer(int* ptr);`

3. **R-value ссылки:**
   - Используются для временных объектов и оптимизации (например, в конструкторах перемещения).
   `void func(int&& x);`

# 6. **l-value и r-value**

- **l-value** (или left-value) есть выражение, которое может _хотя бы раз_ оказаться слева от знака `=`.
- **r-value** (или right-value) есть выражение, которое может оказаться _лишь_ справа от знака `=` и не может оказаться слева.

[Например]

```cpp
int x = 10;          x - lvalue, так как можно написать x=12;
const double y = 19; y - lvalue, так как на этой же строке y оказалась                        слева от знака =.

8;                   8 - r-value, так как нельзя написать, например,                                                                       8=1+3;

x + 1;               x+1 - r-value, так как нельзя написать, например,                                                                   x+1=666;

"Hello World";       "Hello World" - r-value, так как нельзя написать,                         например "Hello World" = "Goodbye World";
```

- У всякого выражения в C++ есть 3 характеристики:
  1. Type         (тип)
  2. Value        (значение)
  3. Side-Effect (побочный эффект)

[Примеры характеристик выражений]

```cpp
- Пример 1.
  
  double a = 19;
  a + 1;
  1. double
  2. 20
  3. Ничего

- Пример 2.
  int a = 7;
  a = 7;
  1. int
  2. 7 (так как если напечатать std::cout << (a=7); выведется 7)
  3. Изменить значение a на 7
   
- Пример 3.
  "Hello World";
  1. char*
  2. "Hello World"
  3. Ничегo
   
- Пример 4.
  int a = 15;
  ++a;
  1. int
  2. 16 (так как если напечатать std::cout << (++a); выведется 16)
  3. Увеличить значение a на 1

   
- Пример 5.
  int a = 15;
  a++;
  1. int
  2. 15 (так как если напечатать std::cout << (a++); выведется 15)
  3. Увеличить значение a на 1
```

**Подытожим**:

```cpp
int a = 15;
std::cout << ++a << "\n"; Напечатает 16, т.е. новое значение а. 
std::cout << a << "\n";   Напечатает 16, так как значение а увеличилось на 1 из-за побочного эффекта ++a.

int a = 15;
std::cout << a++ << "\n"; Напечатает 15, т.е. исходное значение а. 
std::cout << a << "\n";   Напечатает 16, так как значение а увеличилось на 1 из-за побочного эффекта a++.
```

Таким образом префиксный инкремент и постфикстный инкремент увеличивают переменную на 1,
но значение префиксного инкремента - _новое значение_ переменной после увеличения,
а значение постфиксного инкремента - _исходное значение_ переменной до увеличения.

Кроме того:
`++x`; l-value, так как можно написать, например, `++x=12; <---Значение х поменяется на 12.`
`x++`; r-value, так как нельзя написать, например, `x++=12; <---Ошибка компиляции.`

### ЗАМЕЧАНИЕ:

Всё у чего есть имя `l-value`, но всё у чего нет имени ещё не значит, что `r-value`.
**Достаточным условием** того, что какое-то выражение было l-value, является существование имени для этого выражения.

[Например]
1. x;   x-название переменной => оно точно l-value.
2. ++x; ++x не название переменной, но это всё ещё l-value.
3. x++; x++ не название переменной, но в этот раз это r-value.

Другие примеры `l-value` выражений:

```cpp
x = y;
x += 1;
x = x * 20;
--x;
```

Другие примеры `r-value` выражений:

```cpp
x + 1;
std::abs(x);
std::sqrt(y);
10;
's';
3.14;
x--;
```

***ЗАМЕЧАНИЕ***:
char-массивы являются l-value выражениями, но неявно кастятся в r-value.
То есть
```cpp
"This is an r-value expression";
```
eсть r-value выражение.

