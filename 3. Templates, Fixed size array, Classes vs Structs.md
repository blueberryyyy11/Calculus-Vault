##### 3. Function/class templates, Basic implementation of a fixed size array in C++, destructor, copy constructor, assignment operator, private/public/protected, classes, class vs struct, const member functions.

# 1. Class vs Struct

Struct+operators.cpp
```cpp
1. ﻿#include <iostream>
2. #include <cmath>
3. 
4. // Структура есть множество данных (которое называется полем структуры)
5. // и множество функций (называются member functions или методы структуры), которые работают с этими данными.
6. struct Complex
7. {
8. 	//----------------------  Поле структуры:  --------------------------
9. 
10. 	double re;
11. 	double im;
12. 	/*
13. 	После объявления вне структуры (например в main)
14. 		Complex z;
15. 	по сути мы объявим сразу 2 переменные - z.re и z.im
16. 	С ними мы можем делать все действия, которые делали бы с переменными типа double, например:
17. 		int main()
18. 		{
19. 			Complex z;
20. 			z.re = 5.23;
21. 			z.im = ze.re - 2;
22. 			std::cout << z.re << " " << z.im;
23. 		}
24. 	Переменные с типом какой-то структуры называются объектами (например z-объект).
25. 	*/
26. 
27. 	//------------------- Методы структуры: -------------------------
28. 
29. 	double abs() const
30. 	{
31. 		return std::sqrt(re * re + im * im);
32. 	}
33. 	/*
34. 		Данная функция вычисляет абсолютное значение комплексного числа.
35. 		Обращемся к нему через какой-то объект, например z.abs();
36. 
37. 		const - гласит, что данный метод не будет менять поле структуры, т.е. значения re и im не поменяются.
38. 		Если метод небыл бы константным, то его нельзя было бы вызвать из константного объекта, например запись
39. 
40. 		void printAbs(const Complex& complex)
41. 		{
42. 		    std::cout << complex.abs();
43. 		}
44. 
45. 		не скомпилировалась бы, если бы функция abs небыла бы объявлена через const 
46. 		(так как ссылка на объект complex константная).
47. 	*/
48. 
49. 	void add_real(double real)
50. 	{
51. 		re += real;
52. 	}
53. 	/*
54. 		Данная функция прибавляет к вещественной части нашего комплексного числа другое вещественное число.
55. 		Обращемся к нему через какой-то объект и передаем число, например z.add_real(3.14);
56. 
57. 		Заметим, что данная функция не может являтся константной, если попытаться написать в его объявлении
58. 			void add_real(double real) const
59. 		код не скомпилируется, так как мы меняем состояние поля структуры на 51ой строке.
60. 	*/
61. 
62. 	//--------------------------Конструкторы: -----------------------
63. 
64. 	/*
65. 		Конструктор вызывается при создании объекта. 
66. 		Конструктор - это функция, у которого нету возвращаемого типа (даже void), а имя совпадает
67. 		с именем самой структуры. Например:
68. 		
69. 			// конструктор (1)
70. 			Complex(double real_part)
71. 			{
72. 				 re = real_part;
73. 				 im = 0;
74. 			}
75. 
76. 		Чтобы вызвать данный конструктор, необходимо при инициализации объекта передать вещественное число.
77. 		Например:
78. 
79. 			int main()
80. 			{
81. 				 Complex z1(23.5);
82. 				 Complex z2 = -2.4;
83. 			}
84. 
85. 		После записи на 81ой строке вызовется конструктор(1) и будет создан объект z1 с полем re = 23.5, im = 0.
86. 		После записи на 82ой строке вызовется конструктор(1) и будет создан объект z2 с полем re = -2.4, im = 0.
87. 
88. 		ЗАМЕЧАНИЕ 1: Если рядом с объявлением конструктора написать ключегое слово explicit, т. е.
89. 			explicit Complex(double real_part)
90. 		запись на 82ой строке не скомпилируется.
91. 		Данная запись нужна, если мы хотим вызывать конструктор лишь явным образом, а в 82ой строке она вызвана неявно.
92. 
93. 		ЗАМЕЧАНИЕ 2: Одновременно может существовать несколько конструкторов, если они отличаются аргументами. Например
94. 		наряду с конструктором (1) можно объявить другой конструктор
95. 
96. 			// конструктор (2)
97. 			Complex(double real_part, double imaginary_part)
98. 			{
99. 				 re = real_part;
100. 				 im = imaginary_part;
101. 			}
102. 
103. 		Конструктор 2 вызовется если передать при создании объекта сразу 2 вещественных числа. Например
104. 			int main()
105. 			{
106. 				 Complex z1(23.5);
107. 				 Complex z2(-2.4, 9.5);
108. 			}
109. 		После записи на 106ой строке вызовется конструктор(1) и будет создан объект z1 с полем re = 23.5, im = 0.
110. 		После записи на 107ой строке вызовется конструктор(2) и будет создан объект z2 с полем re = -2.4, im = 9.5.
111. 	*/
112. 
113. 	//--------------------- Конструктор по умолчанию: ---------------
114. 
115. 	/*
116. 		Конструктор, который не получает никаких аргументов называется конструктором по умолчанию (default constructor).
117. 		Например:
118. 
119. 			// конструктор (3)
120. 			Complex()
121. 			{
122. 				 re = 0;
123. 				 im = 0;
124. 			}
125. 
126. 		Данный конструктор вызывается, если при создании объекта аргументов передано небыло, например:
127. 
128. 			int main()
129. 			{
130. 				 Complex z;
131. 			}
132. 		
133. 		ЗАМЕЧАНИЕ 1: Если в структуре нету никаких конструкторов, то компилятор генерирует собственный конструктор по умолчанию.
134. 		ЗАМЕЧАНИЕ 2: Если в структуре присутствует хоть 1 конструктор, то конструктор по умолчанию не генерируется. 
135. 		Так например, если объявить лишь конструкторы (1) и (2), то запись на 130 строке не скомпилируется. 
136. 		В ином случае, если никаких конструкторов не объявлено, то компиляция пройдет успешно.
137. 
138. 		ЗАМЕЧАНИЕ 3: Конструкторы (1), (2) и (3) можно объединить в 1:
139. 			
140. 			// конструктор (4)
141. 			Complex(double real_part = 0, double imaginary_part = 0) 
142. 			{
143. 				re = real_part;
144. 				im = imaginary_part;
145. 			}
146. 
147. 	*/
148. 
149. 	//------------------- Member initialization: --------------------
150. 	// конструктор (5)
151. 	Complex(double real_part = 0, double imaginary_part = 0) 
152. 		: re(real_part)
153. 		, im(imaginary_part) 
154. 	{
155. 	}
156. 	/*
157. 		Данная запись отличается от конструктора (4) тем, что значения переменным re и im в (4) задаются уже после их создания.
158. 		То что происходить в конструкторе (4) эквивалентно следующему:
159. 		     double re;
160. 			 double im;
161. 			 re = real_part;
162. 			 im = imaginary_part;
163. 		а в конструкторе (5) происходит следующее:
164. 			 double re = real_part;
165. 			 double im = imaginary_part;
166. 		т.е. значения в этом случае задаются при создании re и im.
167. 	*/
168. 
169. 	//---------------------- Перегрузка операторов: -----------------
170. 
171. 	/*
172. 		Легко заметить, что если объявить лишь вышеуказанные методы, следующая запись не будет компилироваться:
173. 			int main()
174. 			{
175. 				 Complex z1(23.5);
176. 				 Complex z2(-2.4, 9.5);
177. 				 z1 += z2;
178. 			}
179. 		Связанно это с тем, что операция += неопределена для нашей структуры.
180. 		Чтобы эту операцию определить, необходимо перегрузить оператор +=. 
181. 		Оператор перегружается определением метода с названием operator+=, который получает 1 аргумент - второе комплексное число.
182. 		Перегрузить можно следующим образом:
183. 			void operator+=(const Complex& other)
184. 			{
185. 				re += other.re;
186. 				im += other.im;
187. 			}
188. 		Теперь, на 177ой строке будет вызыватся оператор +=, а запись z1 += z2; эквивалентна z1.operator+=(z2);
189. 		Поле класса z1 поменяется на re = 21.1 и im = 9.5
190. 		
191. 		ЗАМЕЧАНИЕ 1: На удивление, запись 
192. 			int main()
193. 			{
194. 				 Complex z(-2.4, 9.5);
195. 				 z += 3.14;
196. 			}
197. 		скомпилируется. Заметим, что на строке 195 z += 3.14; эквивалентна z.operator+=(3.14); 
198. 		Хоть у нас operator+= не принимает значение типа double, на строке 195 сперва вызовется конструктор(5) и 
199. 		оператору += будет передан other с полями re=3.14 и im=0.
200. 
201. 		ЗАМЕЧАНИЕ 2: Заметим, что для обычных чисел (например для int-ов)
202. 			int x = 10;
203. 			int y = 20;
204. 		у выражения x += y; кроме побочного эффекта, есть также значение - 30.
205. 		Действительно, запись std::cout << (x += y); выведет 30, т.е. значение х после прибавления у. 
206. 		Если же x и у комплексные, то x += y вызовет функцию operator+=, определенную на строке 183, а возвращает он void.
207. 		Т.е. если x и y комплексные, то для x += y значения нету (что очень плохо).
208. 
209. 		Таким образом, чтобы решить данный вопрос, необходимо чтобы метод operator+= возвращал бы комплексное число -
210. 		сам объект, operator+= которого был вызван. Т.е. значение записи z1 += z2 должно равнятся значению z1 после сложения.
211. 		Приходим к записи 
212. 			Complex operator+=(const Complex& other)
213. 			{
214. 				re += other.re;
215. 				im += other.im;
216. 
217. 				return *this;
218. 			}
219. 		Тут *this есть объект, для которого вызвалась функция operator+=. Например при записи z1 += z2, т.е. z1.operator+=(z2)
220. 		*this есть объект z1. 
221. 		
222. 		ЗАМЕЧАНИЕ 3: Оператору += стоит возвращать ссылку на Complex, как указано ниже:
223. 	*/
224. 
225. 	Complex& operator+=(const Complex& other)
226. 	{
227. 		re += other.re;
228. 		im += other.im;
229. 
230. 		return *this;
231. 	}
232. 	/*
233. 		Запись Complex& тут по двум причинам:
234. 		1. Чтобы *this не копировался бы.
235. 		2. Так как для обычных чисел запись x+=y является ссылкой для х, действительно, в записи
236. 			int main()
237. 			{
238. 				int x = 10;
239. 				int y = 20;
240. 				(x+=y) = -7;
241. 			}
242. 		значение х будет изменено на -7.
243. 	*/
244. 
245. 	//Аналогично определяются другие операторы:
246. 
247. 	Complex& operator-=(const Complex& other)
248. 	{
249. 		re -= other.re;
250. 		im -= other.im;
251. 
252. 		return *this;
253. 	}
254. 
255. 	Complex& operator*=(const Complex& other)
256. 	{
257. 		re = re*other.re - im*other.im;
258. 		im = re*other.im + im*other.re;
259. 
260. 		return *this;
261. 	}
262. 
263. 	Complex& operator/=(const Complex& other)
264. 	{
265. 		// сделай сам
266. 
267. 		return *this;
268. 	}
269. 
270. 	//------------------------ Другие операторы: --------------------
271. 
272. 	/*
273. 		Рассмотрим перегрузку оператора +
274. 
275. 		Complex operator+(const Complex& other)
276. 		{
277. 			Complex result;
278. 			result.re = re + other.re;
279. 			result.im = im + other.im;
280. 
281. 			return result;
282. 		}
283. 
284. 		ЗАМЕЧАНИЕ 1: operator+ возвращает уже не ссылку, а результат в виде объекта. Делается это из технических соображений, 
285. 		так как result есть временная переменна (можно было также записать вместо возвращаемого типа const Complex&)
286. 
287. 		ЗАМЕЧАНИЕ 2: данный operator+ МОЖЕТ быть вызван следующими способами:
288. 			Способ 1:
289. 
290. 			int main
291. 			{
292. 				 Complex z1(23.5);
293. 				 Complex z2(-2.4, 9.5);
294. 				 Complex sum = z1 + z2;
295. 			}
296. 
297. 			Способ 2:
298. 
299. 			int main
300. 			{
301. 				 Complex z(-2.4, 9.5);
302. 				 Complex sum = z + 3.1;
303. 			}
304. 		При первом способе запись z1 + z2; эквивалентна z1.operator+(z2);
305. 		Во втором способе запись z1 + 3.1; эквивалентна z1.operator+(3.1);  (смотри operator+= чтоб понять почему это работает)
306. 
307. 		Замечание 3: Данный operator+ НЕ МОЖЕТ быть вызван следующим способом:
308. 
309. 			Способ 3:
310. 
311. 			int main
312. 			{
313. 				 Complex z(-2.4, 9.5);
314. 				 Complex sum = 4 + z;
315. 			}
316. 		так как запись 4.operator+(z) не имеет смысла.
317. 		Чтобы запись на строке 314 скомпилировалась, необходимо operator+ убрать из структуры, как это сделано ниже.
318. 	*/
319. 
320. };  //<-------------- Заметте, структура заканчивается записью ;
321. 
322. // ------------------ Операторы вне структуры: ---------------------
323. 
324. /*
325. 	Как было указано в замечании 3 для других операторов, operator+ стоит определить вне структуры.
326. 	Делается это следующим образом:
327. 
328. 	Complex operator+(const Complex& lhs, const Complex& rhs)
329. 	{
330. 		Complex result;
331. 		result = lhs.re + rhs.re;
332. 		result = lhs.im + rhs.im;
333. 
334. 		return result;
335. 	}
336. 
337. 	Данная запись позволяет вызвать оператор + как Способами 1-2, так и Способом 3. 
338. 	Способ 3 работает из за следующей причины: Если компиляция 4.operator+(z) не пройдет, компилятор для строки 314
339. 	попытается скомпилировать operator+(4, z), а данная компиляция пройдет, так как для 4 есть конструктор (см. operator+=).
340. 
341. 	Но есть более элегантный способ записи данной функции, где используется уже определенный оператор += указанный ниже:
342. */
343. Complex operator+(Complex lhs, const Complex& rhs)
344. {
345. 	return lhs += rhs;
346. }
347. 
348. Complex operator-(Complex lhs, const Complex& rhs)
349. {
350. 	return lhs -= rhs;
351. }
352. 
353. Complex operator*(Complex lhs, const Complex& rhs)
354. {
355. 	return lhs *= rhs;
356. }
357. 
358. Complex operator/(Complex lhs, const Complex& rhs)
359. {
360. 	return lhs /= rhs;
361. }
362. 
363. //---------------------- Операторы << и >>: ------------------------
364. 
365. /*
366. 	Рассмотрим код:
367. 
368. 	int main
369. 	{
370. 		Complex z(-2.4, 9.5);
371. 		std::cout << z;
372. 	}
373. 
374. 	Легко можно понять: для того, чтобы запись в 371 строке скомпилировалась бы, компилатор будет сперва пытаться скомпилировать
375. 		std::cout.operator<<(z);
376. 	std::cout также является объектом (а именно - объект, приводящийся к типу std::ostream&).
377. 	std::ostream - другая структура. Разумеется, в этой структуре нету оператора <<, который получал бы значение типа Complex.
378. 	Таким образом, так как operator<< нельзя определеить внутри структуры std::ostream, надо определить вне:
379. 
380. 	void operator<<(std::ostream& out, const Complex& complex)
381. 	{
382. 		out << "(" << complex.re << ", " << complex.im << ")";
383. 	}
384. 
385. 	Таким образом в 371ой строке будет вызван operator<<(std::cout, z);
386. 
387. 	ЗАМЕЧАНИЕ 1: Заметте, что переменную out функция получает через ссылку. Связано это с тем, что сам объект std::cout меняет
388. 	состояние своего поля после записи std::cout << z; (меняет место маркера в консоли).
389. 
390. 	ЗАМЕЧАНИЕ 2: Нижеприведенный код
391. 
392. 	int main
393. 	{
394. 		Complex z(-2.4, 9.5);
395. 		std::cout << z << " is a great complex number!";
396. 	}
397. 
398. 	не скомпилируется, так как запись в 395ой строке эквивалентна operator<<(std::cout, z)<<" is a great complex number!";
399. 	А operator<< возвращает void и конечно, запись void<<" is a great complex number!"; не имеет смысла. По этому данная 
400. 	функцуя должна возвращать сам объект out:
401. */
402. 
403. std::ostream& operator<<(std::ostream& out, const Complex& complex)
404. {
405. 	out << "(" << complex.re << ", " << complex.im << ")";
406. 
407. 	return out;
408. }
409. 
410. 
411. /*
412. 	std::cin же является объектом, приводящийся к типу std::istream&.
413. 	Зная это обеспечте компиляцию следующего кода:
414. 
415. 	int main
416. 	{
417. 		Complex z;
418. 		std::cin >> z;
419. 	}
420. 
421. */
422. 
423. int main()
424. {
425. }

```
# 2. Basic implementation of a fixed size array in C++

FixedSizeArray.h
```cpp
  1. #pragma once
  2. #include <cstddef>
  3. 
  4. /*
  5. ----------->[ВОПРОС] Чем отличается класс от структуры?
  6. Ответ: Класс отличается от структуры лишь двумя вещами.
  7. 1. Все мемберы класса (как переменные так и функции) в структуре доступны
  8. повсеместно если ничего другого не писать (все public). В классе наоборот - все мемберы класса
  9. не доступны никому если ничего другого не писать (все private).
 10. 2. Тип наследования от структуры - public, а тип наследования от класса - private (в этих файлах это не используется).
 11. 
 12. Интерфейс - всё то, что позволяет общаться с классом вне самого класса
 13. (для нижеопределенного класса - это функции, объявленные под public:)
 14. 
 15. Хорошей практикой является декларировать мембер функции в одном файле, а имплементировать в другом (Interface Segregation Principle).
 16. В данном файле написаны лишь декларации упомянутых функций, их имплементация может быть найдена в файле FixedSizeArray.cpp.
 17. */
 18. class FixedSizeArray
 19. {
 20. 
 21. /*
 22. Если написать внутри класса ключевое слово private: тогда то, что окажется под этим модификатором
 23. доступа станет недоступным нигде, кроме самого класса. Если же писать модификатор доступа public:
 24. то всё то, что под ним окажется станет доступным.
 25. 
 26. Данный класс обладает двумя переменными - m_arr и m_size с модификатором доступа private, а также
 27. функциями size, operator[], конструкторами и деструктором с модификатором доступа public.
 28. */
 29. private:
 30.    int* m_arr;
 31.    std::size_t m_size;
 32. /*
 33.    ----------->[ВОПРОС] Почему m_arr и m_size в private?
 34.    Ответ: Так как объект данного класса из себя должен представлять массив фиксированной длины (FixedSizeArray),
 35.    следовательно размер массива на который указывает m_arr должен равнятся значению m_size всегда и повсюду.
 36.    Следовательно мы не хотим, чтобы у человека, который будет использовать наш класс в своих грязных целях
 37.    даже появилась бы мысль поменять значение m_arr или m_size, a даже если бы и появилась бы - то он не смог.
 38. 
 39.    В общем и целом - модификаторы доступа нужны, чтобы в самом классе не появлялось бы внутренних противоречий.
 40. 
 41.    ----------->[ВОПРОС] Почему у m_size тип std::size_t?
 42.    Ответ: std::size_t определен в заголовочном файле <cstddef> и представляет из себя неотрицательный целочисленный
 43.    тип, который способен в себе хранить наибольший размер куска памяти, который поддерживается самой системой.
 44.    В 32-битной системе размер std::size_t 32 бита, а в 64-битной системе размер std::size_t 64 бита.
 45.    Его будем использовать для размеров, индексов и количества.
 46. */
 47. 
 48. public:
 49.    /* Конструкторы (Если непонятно - посмотри "Struct + operators.cpp" конструкторы)
 50. 
 51.    FixedSizeArray(std::size_t size); - Принимает size и создает массив размера size, элементы которых неинициализованны․
 52. 
 53.    FixedSizeArray(std::size_t size, int val); - Принимает size, val и создает массив размера size где каждый элемент равен val․
 54.    */
 55.    FixedSizeArray(std::size_t size);
 56. 
 57.    FixedSizeArray(std::size_t size, int val);
 58. 
 59.    /* std::size_t size() const;
 60. 
 61.    Хоть мы и не хотим, чтобы юзер мог бы изменять значения наших мембер филдов - мы не имеем право не дать
 62.    ему каким-то образом получить, ну, хотя бы размер массива, с которым он работает, поэтому логично было бы
 63.    создать функцию, которая возвращала бы размер массива. Для этого служит функция size().
 64.    Замечание: Если непонятно, почему написано const справа от функции - посмотри файл "Struct + operators.cpp" (функция abs)
 65.    */
 66.    std::size_t size() const;
 67. 
 68.    /* int& operator[](std::size_t index);
 69. 
 70.    Если не знаешь, что такое перегрузка операторов -
 71.    посмотри файл "Struct + operators.cpp" (функции operator+=, -=, *=, /=, +, -, *, /, <<).
 72. 
 73.    operator[] служит для того, чтобы обратиться к элементу массива через определенный индекс.
 74.    Например:
 75. 
 76.    int main()
 77.    {
 78.       FixedSizeArray fsArr(10, -3); // Создает массив размера 10, каждый элемент которого равен -3.
 79. 
 80.       std::cout << fsArr;
 81.       return 0;
 82.    }
 83. */
 84.    ----------->[ВОПРОС] Почему operator[] возвращает референс?
 85.    Ответ: Если бы operator[] возвращал бы просто int, т.е. имел бы вид
 86. 
 87.    int operator[](std::size_t index);
 88. 
 89.    Тогда нельзя было бы писать
 90.    int main()
 91.    {
 92.       FixedSizeArray fsArr(10, -3); // Создает массив размера 10, каждый элемент которого равен -3.
 93. 
 94.       fsArr = -11; 
 95.                       // который бы вернул r-value значение, а оно не может быть слева от знака равно => Compile error.
 96.       return 0;
 97.    }
 98. 
 99.    Если же operator[] возвращает референс, то на 94-eй строке operator[] вернет l-value значение,
100.    что позволит поменять значение элемента массива с индексом 4 на -11.
101. 
102.    ----------->[ВОПРОС] Почему этот operator[] не const?
103.    Ответ: Если бы мы написали
104. 
105.    int& operator[](std::size_t index) const;
106. 
107.    Тогда можно было бы менять элементы массива с константного объекта, т.е. например:
108. 
109.    int main()
110.    {
111.       const FixedSizeArray fsArr(10, -3);
112. 
113.       fsArr вернет неконстантный референс
114.                       // и можно будет поменять значение элемента массива с индексом 4.
115.       return 0;
116.    }
117. 
118.    Поэтому данная функция не объявлена через const,
119.    что приведет к тому, что запись на 113ой строке просто приведет к ошибке компиляции.
120. 
121.    ----------->[Вопрос] А что если кто-нибудь захочет написать следующее?
122. 
123.    int main()
124.    {
125.       const FixedSizeArray fsArr(10, -3);
126. 
127.       std::cout << fsArr[4]; // Тут же значение fsArr[4] не меняется, а просто печатается, но так как
128.                              // будет вызван fsArr.operatorArr-константный, operator[] - не константный,
129.                              // следовательно произойдет compile error.
130.       return 0;
131.    }
132. 
133.    Ответ: Мы хотим от operator[] сразу 2 вещи
134.    1. Если operator[] вызван из неконстантного объекта, то он должен вернуть неконстантный референс.
135.    2. Если operator[] вызван из константного объекта, то он должен вернуть константный референс.
136. 
137.    Первый пункт уже готов, но на данный момент operator[] нельзя вызвать из константного объекта.
138.    Поэтому: Создаем еще один operator[], который будет вызываться из константных объектов.
139.    */
140.    int& operator[](std::size_t index);
141. 
142.    /* const int& operator[](std::size_t index) const;
143. 
144.    Нижеприведенный operator[] служит для получения значения элемента массива из константного объекта.
145.    Подытожив всё то, что было сказано, имеем следующее:
146. 
147.    int main()
148.    {
149.       FixedSizeArray fsArr1(10, -3);        // Неконстантный объект.
150.       const FixedSizeArray fsArr2(20, -5);  // Константный объект.
151. 
152.       std::cout << fsArr1[4];ределенный на строке 140.
153.                                             // Вернет int&, напечатает значение 4-го элемента, ошибки компиляции не будет.
154.       fsArr1[7] ределенный на строке 140.
155.                                             // Вернет int&, поменяет значение 7-го элемента на 100, ошибки компиляции не будет.
156.       
157.       std::cout << fsArr2[4];ределенный на строке 164.
158.                                             // Вернет const int&, напечатает значение 4-го элемента, ошибки компиляции не будет.
159.       fsArr2[7] ределенный на строке 164.
160.                                             // Вернет const int&, поменять значение элемента через константный референс не сможет, ошибка компиляции.
161.       return 0;
162.    }
163.    */
164.    const int& operator[](std::size_t index) const;
165. 
166.    /* Деструктор.
167.    
168.    ----------->[Замечание] Как известно, если что-то было объявлено при помощи new, то оно должно быть удалено при помощи delete, иначе - memory leak.
169.    ----------->[Вопрос] Переменная m_arr инициализируется в обоих конструкторах через m_arr(new int[size]), но нигде не удаляется. Что же делать?
170.    Ответ: Наряду с конструкторами, которые вызываются, когда объект только создан, есть также их антиподы - деструкторы.
171.    Они вызываются когда объект вот-вот будет удален. Например:
172. 
173.    int main()
174.    {
175.       int n;
176.       std::cin >> n;
177. 
178.       if(n%2 == 0)
179.       {
180.          FixedSizeArray fsArr(10, -4); // Создается массив в конструкторе через new.
181. 
182.          std::cout << fsArr[3];        // Делаются с массивом какие-то действия.
183.          fsArr[2] = 19;
184.       }                                // Как только мы вышли из тела if вызывается деструктор - идеальный момент, чтоб удалить m_arr.
185. 
186.       return 0;
187.    }
188. 
189.    ----------->[Синтаксис] Деструктор имеет тот же синтаксис, что и дефолтный конструктор, только с знаком ~ (тильда) в начале.
190.    ----------->[Вопрос] Может ли деструктор принимать аргументы?
191.    Ответ: нет.
192.    */
193.    ~FixedSizeArray();
194. 
195.    /* Конструктор Копирования (Copy Constructor).
196.    ----------->[Вопрос] Что будет, если данная функция отсутствует и написать нижеприведенный код?
197. 
198.    int main()
199.    {
200.       FixedSizeArray fsArr1(10, -3);
201.       FixedSizeArray fsArr2 = fsArr1;
202.       return 0;
203.    }
204.    Ответ: Ничего хорошего.
205.    Для начала поймем, что у нас на 200-ой строке создается объект нашего класса, имеющий вид
206. 
207.    _____________
208.    |  fsArr1   |
209.    -------------
210.    |           |
211.    | m_size=10 |
212.    |           |
213.    |-----------|
214.    |           |
215.    |   m_arr ------------------> [-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
216.    |           |
217.    -------------
218. 
219.    Далее, на 201-ой строке создаем объект fsArr2 на основе fsArr1 и если copy constructor отсутствует,
220.    произойдет следующее
221. 
222.    fsArr2.m_size = fsArr1.m_size;
223.    fsArr2.m_arr = fsArr1.m_arr;
224. 
225.    И наши объекты примут следующий вид
226.                             _____________
227.                             |  fsArr2   |
228.                             -------------
229.                             |           |
230.                             | m_size=10 |
231.                             |           |
232.                             |-----------|
233.                             |           |
234.                             |   m_arr   |
235.                             |     |     |
236.                             ------|------
237.    _____________                   |
238.    |  fsArr1   |                   |
239.    -------------                   |
240.    |           |                   |
241.    | m_size=10 |                   |
242.    |           |                   |
243.    |-----------|                   |
244.    |           |                   v
245.    |   m_arr ------------------> [-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
246.    |           |
247.    -------------
248. 
249.    Во-первых: Оба объекта указывают на один и тот же кусок памяти, что не есть хорошо, мы хотим скопировать наши массивы.
250.    Во-вторых: Это все UB (Undefined Behavior) так как для каждого из объектов на 202-ой строке будет вызван деструктор,
251.              что приведет к двойному удалению памяти (а это по-стандарту UB).
252. 
253.    ----------->[Вопрос] Что же делать?
254.    Ответ: Когда на строке 201 мы пишем
255.    
256.    FixedSizeArray fsArr2 = fsArr1;
257. 
258.    Вызывается copy construtor, синтаксис которого видите ниже.
259.    Данный конструктор также вызывается, если писать
260. 
261.    FixedSizeArray fsArr2(fsArr1);
262. 
263.    Или же передать объект функции по-значению, например
264. 
265.    void f(FixedSizeArray arr)
266.    {
267.       // Что-то.
268.    }
269. 
270.    int main()
271.    {
272.       FixedSizeArray fsArr(10, -20);
273. 
274.       f(fsArr); // Вызовется copy-constructor для инициализации arr на основе fsArr.
275.    }
276. 
277.    И в прочих местах где в принципе может скопироваться объект.
278.    А это идеальное место, чтобы написать как именно скопировать наш объект и чтоб строка 201 приводила бы к следующему результату.
279. 
280.                              _____________
281.                              |  fsArr2   |
282.                              -------------
283.                              |           |
284.                              | m_size=10 |
285.                              |           |
286.                              |-----------|
287.                              |           |
288.                              |   m_arr ------------------> [-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
289.                              |           |
290.                              -------------
291.    _____________
292.    |  fsArr1   |
293.    -------------
294.    |           |
295.    | m_size=10 |
296.    |           |
297.    |-----------|
298.    |           |
299.    |   m_arr ------------------> [-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
300.    |           |
301.    -------------
302. 
303.    Т.е. сделать так, чтобы вместо копирования аддресса fsArr1 в fsArr2 скопировался бы весь кусок памяти, на который ссылвается m_arr.
304.    Как именно это сделано - подробнее смотри в FixedSizeArray.cpp.
305.    */
306.    FixedSizeArray(const FixedSizeArray& other);
307. };
```

FixedSizeArray.cpp
```cpp
  1. // Для того, чтобы отделить имплементацию от декларации всю имплементацию
  2. // функций переводим в данный .cpp файл, а в .h файле пишем декларации функций.
  3. 
  4. // Сперва инклюднем .h файл, где задекларированы все функции, которые будем имплементировать. 
  5. #include "FixedSizeArray.h"
  6. 
  7. // Если декларация в классе имеет вид
  8. // 
  9. // «возвращаемый тип» «название функции»(«аргументы»);
 10. //
 11. // То в .cpp файле имплементация функции будет иметь вид
 12. //
 13. // «возвращаемый тип» «название класса»::«название функции»(«аргументы»)
 14. // {
 15. //     «тело функции»;
 16. // }
 17. //
 18. // Например, в .h файле функция size задекларирована как
 19. //
 20. // std::size_t size() const;
 21. //
 22. // а в данном файле она должа иметь нижеприведенный вид,
 23. // причем полное название функции size - это FixedSizeArray::size().
 24. std::size_t FixedSizeArray::size() const
 25. {
 26.     return m_size;
 27. }
 28. 
 29. // То, что было сказано для обычных мембер-функций верно и для конструкторов,
 30. // т.е. если конструктор задекларирован в .h файле как
 31. //
 32. // «название класса»(«аргументы»)
 33. //
 34. // то ее имплементация будет иметь вид
 35. //
 36. // «название класса»::«название класса»(«аргументы»).
 37. // 
 38. // Ниже можете видеть пример конструктора, который получает размер массива,
 39. // создает сам массив в heap-е, сохранив указатель на первый элемент m_arr,
 40. // также сохраняет значение переданного размера в m_size.
 41. FixedSizeArray::FixedSizeArray(std::size_t size)
 42.     : m_arr(new int[size])
 43.     , m_size(size)
 44. {
 45. }
 46. 
 47. // Данный же конструктор принимает 2 аргумента
 48. // 1. Размер массива
 49. // 2. Значение, которым надо заполнить все элементы массива
 50. // Делает данный конструктор то же самое, что и верхний конструктор,
 51. // просто дополнительно проходит по всем элементам созданного массива и 
 52. // приравнивает к каждому элементу переданное значение val.
 53. FixedSizeArray::FixedSizeArray(std::size_t size, int val)
 54.     : m_arr(new int[size])
 55.     , m_size(size)
 56. {
 57.     for (std::size_t i = 0; i < size; ++i)
 58.     {
 59.         m_arr[i] = val;
 60.     }
 61. }
 62. 
 63. // О данных двух функциях уже было сказано в .h файле.
 64. // Они просто возвращают референс на элемент массива соответствующий индексу.
 65. int& FixedSizeArray::operator[](std::size_t index)
 66. {
 67.     return m_arr[index];
 68. }
 69. 
 70. const int& FixedSizeArray::operator[](std::size_t index) const
 71. {
 72.     return m_arr[index];
 73. }
 74. 
 75. // В деструкторе просто удаляем массив, на который указывает m_arr.
 76. FixedSizeArray::~FixedSizeArray()
 77. {
 78.     delete[] m_arr;
 79. }
 80. 
 81. // В конструкторе копирования создается новый массив того же размера, что и
 82. // массив переданного объекта other, после чего копируется содержание массива other.m_arr
 83. // в m_arr.
 84. FixedSizeArray::FixedSizeArray(const FixedSizeArray& other)
 85.     : m_arr(new int[other.m_size])
 86.     , m_size(other.m_size)
 87. {
 88.     for (std::size_t i = 0; i < m_size; ++i)
 89.     {
 90.         m_arr[i] = other[i];
 91.     }
 92. }
```


# 3. Function/class templates

TemplateFixedSizeArray.h
```cpp
  1. #pragma once
  2. #include <cstddef>
  3. #include <iostream>
  4. #include <string>
  5. 
  6. // В данном файле объясняются
  7. // 1. Функции template
  8. // 2. Классы template
  9. // 3. Отделение интерфейса от реализации для темплейт классов
 10. // 4. Реализация мув конструктора и оператора присваивания
 11. 
 12. // Допустим мы хотим создать функцию, которая печатает переданное значение.
 13. // Пример:
 14. void print(int x)
 15. {
 16.    std::cout << x << "\n";
 17. }
 18. // Отлично! При вызове print(777); будет напечатано 777, но что если надо также уметь печатать строки?
 19. // Разумеется если сейчас вызвать print("Hello World!"); будет ошибка компиляции. Поэтому мы решаем использовать
 20. // перегрузку функций.
 21. void print(std::string str)
 22. {
 23.    std::cout << str << "\n";
 24. }
 25. // Теперь если вызвать print(777); вызовется первая функция, а если вызвать print("Hello World!"); вторая.
 26. // Но что если мы попытаемся вызвать print('c'); ? Ведь 'c' char и для этого типа нет соответствующей функции.
 27. // Вот мы и создаем еще одну функцию
 28. void print(char c)
 29. {
 30.    std::cout << c << "\n";
 31. }
 32. 
 33. // --------> [ВОПРОС] Для каких еще типов надо определить данную функцию?
 34. // Ответ: Как раз для таких случаев и созданы функции-шаблоны (function templates).
 35. // Синтаксис определения функции-шаблона (function template) следующий
 36. //
 37. // template <typename «Название Типа» >
 38. // «определение функции»
 39. //
 40. // Например:
 41. //
 42. // template <typename T>
 43. // void print(T value)
 44. // {
 45. //    std::cout << value << "\n";
 46. // }
 47. //
 48. // Но данную функцию можно улучшить, так как нам ненужна копия передаваемого значения для печатания
 49. // пусть функция получает данное значение по константной ссылке 
 50. template <typename T>
 51. void printValue(const T& value)
 52. {
 53.    std::cout << value << "\n";
 54. }
 55. 
 56. // В данный момент printValue не является функцией, а является шаблоном.
 57. // На его основе создаются функции.
 58. //
 59. // Например: Если вызвать где-нибудь в коде printValue(777); тогда во время компиляции автоматически будет создана функция
 60. //
 61. // void printValue(const int& value) // T=int, так как 777-это int.
 62. // {
 63. //    std::cout << value << "\n";
 64. // }
 65. //
 66. // А если вызвать где-нибудь еще printValue("Hello World!") тогда также будет создана функция
 67. //
 68. // void printValue(const char*& value) // T=char*, так как тип "Hello World!" - это char*
 69. // {
 70. //     std::cout << value << "\n";
 71. // }
 72. // 
 73. // Замечание: Если же еще где-то вызвана функция printValue(12345); новой функции создано не будет, а будет вызвана
 74. //            функция созданная на строке 61.
 75. //
 76. // Созданные функции называются template functions.
 77. // Подытожим: То что было создано на строке 51 называется function template, и это не функции, а шаблоны,
 78. //            а то, что было создано на строках 61 и 68 - template function, и это уже функции.
 79. // 
 80. // -------->[ВОПРОС] А что если мы хотим передать "Hello World" не как char*, а как std::string?
 81. // Ответ: Вот функция, в которой передает "Hello World" как строку функции printValue несколькими способами
 82. void pass_hello_world_as_string()
 83. {
 84.    // -------------->[СПОСОБ 1]
 85.    std::string str{"Hello World"}; // Напрямую создать std::string и передать.
 86.    printValue(str);
 87. 
 88.    // -------------->[СПОСОБ 2]
 89.    printValue<std::string>("Hello World"); // Тут значение T в printValue вручную определяется как T=std::string.
 90.    // Подробно: На самом деле название фенерируемой функции не просто printValue, а printValue<T>
 91.    //           Вызывая printValue<std::string>, мы как-бы вручную говорим, что T=std::string и не позволяем
 92.    //           компилятору дедуцировать тип "Hello World" как char*, а заставляем сгенерировать функцию
 93.    // 
 94.    //           void printValue(const std::string& value);
 95.    //
 96.    //           И сконвертировать "Hello World" в std::string.
 97. 
 98. 
 99.    // -------------->[СПОСОБ 3]
100.    // Использовать std::string_literals. Делается это так:
101.    using namespace std::string_literals; // После данной комманды, если написать s после ковычек, тогда тип текста
102.                                          // в ковычках уже будет не типа char*, а будет типа std::string.
103.    printValue("Hello World"s); // Заметим, что после "Hello World" написано s, значит будет иметь тип std::string.
104. }
105. 
106. // В FixedSizeArray.h мы объявили массив типа int. Но что если мы хотим уметь создавать массивы любых типов?
107. // Для такого случая и созданы классы-шаблоны (class templates). Определяются они почти тем же способом
108. // как и функции-шаблоны.
109. 
110. // template <typename «Название Типа» >
111. // «определение класса»
112. template <typename T>
113. class FixedSizeArray
114. {
115. private:
116.    T* m_arr;           
117.    std::size_t m_size;
118.    // Тут вместо int* m_arr; напишем T* m_arr; таким образом будем хранить тот тип данных,
119.    // который и был определен для нашего объекта. А определяется он следующим образом:
120.    //
121.    // int main()
122.    // {
123.    //    FixedSizeArray<double> arr1(10); // Тут T=double, и m_arr будет указателем на массив из double-ов.
124.    //    FixedSizeArray<std::string> arr2(77); // Тут T=std::string, и m_arr будет указателем на массив строк.
125.    // }
126.    //
127.    // По аналогии с функциями: FixedSizeArray - это class template,
128.    // a FixedSizeArray<double> и FixedSizeArray<std::string> - это template classes.
129.    // И для каждого типа генерируется свой собственный отдельный класс.
130. 
131. public:
132.    // Далее - повсюду вместо типа int напишем T.
133. 
134.    //---Старые функции, которые были определены в FixedSizedArray.h-
135. 
136.    FixedSizeArray(std::size_t size);
137. 
138.    FixedSizeArray(std::size_t size, T val);
139. 
140.    std::size_t size() const;
141. 
142.    T& operator[](std::size_t index);
143. 
144.    const T& operator[](std::size_t index) const;
145. 
146.    ~FixedSizeArray();
147. 
148.    FixedSizeArray(const FixedSizeArray& other);
149. 
150.    //----Функции, неопределенные в FixedSizedArray.h----------------
151. 
152.    // move constructor (Подробно смотри в MoveSemantics.cpp, тут же смотри имплементацию)
153.    FixedSizeArray(FixedSizeArray&& other);
154. 
155.    // FixedSizeArray& operator=(const FixedSizeArray& other);
156.    // 
157.    // Как мы уже знаем, если написать
158.    //
159.    // int main()
160.    // {
161.    //    FixedSizeArray<int> fsArr1(10, 2);
162.    //    FixedSizeArray<int> fsArr2 = fsArr1;
163.    // }
164.    // 
165.    // то на 162ой строке будет вызван copy-конструктор, определенный на строке 148.
166.    // Что же происходит, если написать
167.    // 
168.    // int main()
169.    // {
170.    //    FixedSizeArray<int> fsArr1(10, 2);
171.    //    FixedSizeArray<int> fsArr2(7);
172.    // 
173.    //    fsArr2 = fsArr1;
174.    // }
175.    // 
176.    // Поймем, что на 173-ей строке copy-конструктор не вызывается, так как fsArr2 уже создан на строке 171.
177.    // Ну как мы уже знаем, для бинарных действий вызывается соответствующий оператор, в данном случае - operator=.
178.    // Вызов имеет вид fsArr2.operator=(fsArr1); если данный оператор будет отсутствовать, то компилятор
179.    // сгенерирует свой собственный operator=, который будет делать следующее
180.    //
181.    // FixedSizeArray& operator=(const FixedSizeArray& other)
182.    // {
183.    //    m_arr = other.m_arr;
184.    //    m_size = other.m_size;
185.    // 
186.    //    return *this;
187.    // }
188.    //
189.    // Тут 183-ая строка приведет к той ситуации, которую мы видели на строках 196-253 в FixedSizeArray.h,
190.    // Если коротко - fsArr1 и fsArr2 будут показывать на тот же кусок памяти, что приведет к двойному
191.    // удалению одной и той же памяти при вызове деструкторов, а это undefined behavior.
192.    // Именно поэтому мы создаем собственный operator=, где копируем не указатель m_arr, а сам массив (смотри реализацию ниже).
193.    //
194.    // -------->[ВОПРОС] Что такое this?
195.    // Ответ: this - это указатель на объект, для которого был вызван сам метод.
196.    // Например, если рассмотреть вызов operator= на строке 173, который из себя представляет fsArr2.operator=(fsArr1);
197.    // то внутри operator= this будет указывать на fsArr2, а *this будет референсом на fsArr2, other - референс на fsArr1.
198.    //
199.    // -------->[ВОПРОС] Зачем operator= возвращает *this?
200.    // Ответ: Для ответа на этот вопрос рассмотрим следующий код
201.    // 
202.    // int main()
203.    // {
204.    //    int x = 10;
205.    //    int y = 20;
206.    //    int z = 30;
207.    // 
208.    //    (x = y) = z;
209.    //    
210.    //    std::cout << x << " " << y << " " << z;
211.    // }
212.    //
213.    // Как уже было сказано в References.cpp - всякое выражение в C++ имеет тип, значение и побочный эффект.
214.    // Тип x=y: int&
215.    // значение: референс на х
216.    // побочный эффект: приравнять y к х.
217.    //
218.    // Подытожив: x=y приравняет y к х, но само это выражение есть референс на х, следовательно после к х будет присвоено значение z.
219.    // а на 208ой строке будет напечатано "30 20 30".
220.    //
221.    // Именно поэтому operator= возвращает референс на объект слева от знака =.
222.    //
223.    // кроме этого, если рассмотреть код
224.    // int main()
225.    // {
226.    //    int x = 10;
227.    //    int y = 20;
228.    //    int z = 30;
229.    // 
230.    //    x = y = z;
231.    //    
232.    //    std::cout << x << " " << y << " " << z;
233.    // }
234.    //
235.    // тут на 228ой стрике скобки отсутствуют операции пройдут справа налево, т.е.
236.    // 1. к y будет присвоено значение z,
237.    // 2. к х будет присвоено значение y.
238.    //
239.    // Замечание1: Операция равенства единственная бинарная операция, которая происходит справа налево.
240.    // Замечание2: Всякая мембер-функция класса (в том числе конструктор и деструктор) получает в качестве аргумента this.
241.    //             В самом деле, если объект obj класса А, который имеет функцию f(int) вызывает f,
242.    //             т.е. obj.f(2), изнутри происходит A::f(&obj, 2); где &obj адресс obj, который и будет присвоен к this.
243.    FixedSizeArray& operator=(const FixedSizeArray& other);
244. 
245.    // FixedSizeArray& operator=(FixedSizeArray&& other);
246.    //
247.    // Рассмотрим следующий сценарий:
248.    //
249.    // int main()
250.    // {
251.    //    FixedSizeArray<int> fsArr1(10, 2);
252.    //    FixedSizeArray<int> fsArr2(7);
253.    //    
254.    //    // ...Какие-то действия
255.    //    // надо присвоить значение fsArr1 к fsArr2, но fsArr1 уже ненужен.
256.    //    fsArr2 = fsArr1;
257.    //    
258.    //    // ...Какие-то действия
259.    // }
260.    // 
261.    // На строке 256 будет создана копия массива fsArr1.m_arr, но старый массив уже ненужен, что делать чтоб избежать копирования?
262.    // Ответ: fsArr2 = std::move(fsArr1);
263.    // Но чтобы сам массив нескопировался бы нужно иметь move-assignment оператор, который и определен снизу.
264.    // 
265.    // Замечание: Ситуация такая же, как и при реализации move-конструктора, просто сейчас объект уже создан.
266.    FixedSizeArray& operator=(FixedSizeArray&& other);
267. };
268. 
269. // Сперва поговорим про отделении реализации мембер функций от их декларации на примере функции size().
270. // На самом деле полное название функции size() - это FixedSizeArray<T>::size(), где T - это тип, определенный
271. // на строке 112 и данный тип работает только в данном классе (заметте, что внутри класса название класса
272. // записывается как FixedSizeArray, а не FixedSizeArray<T>, так как компилятор понимает, что внутри класса - это одно и то же).
273. //
274. // Но для того чтобы реализовать функцию вне класса, надо объявить template <typename T> (или вместо Т другую букву, разницы нет)
275. // и писать полное имя данного класса. Также было сделано и в FixedSizeArray.h и в FixedSizeArray.cpp, но тогда
276. // данный класс не был шаблонным, и мы спокойно писали FixedSizeArray::size().
277. //
278. // ------->[ВОПРОС] В FixedSizeArray.h и FixedSizeArray.cpp мы декларировали функции в .h файле, а реализовывали в .cpp, почему сейчас всё в .h файле?
279. // Ответ: Не можем отделить. Если попытаться отделить реализации функций в отдельный .cpp файл, данный .cpp будет скомпилирован
280. // лишь единожды отдельно от остальных .cpp файлов, и в момент компиляции будет непонятно, для каких типов
281. // генерировать определенные функции. А если все писать в .h файле, такой проблемы не возникнет.
282. template <typename T>
283. std::size_t FixedSizeArray<T>::size() const
284. {
285.    return m_size;
286. }
287. 
288. // Далее рассмотрим мув конструктор
289. //
290. // Как можем видеть, тут просто копируются поля данных классов, и к other.m_arr приравнивается nullptr.
291. // Всё так, как уже было объяснено в MoveSemantics.cpp в строках 70-94.
292. template <typename T>
293. FixedSizeArray<T>::FixedSizeArray(FixedSizeArray&& other)
294.    : m_arr(other.m_arr)
295.    , m_size(other.m_size)
296. {
297.    other.m_arr = nullptr;
298. }
299. 
300. // Рассмотрим assignment operator
301. template <typename T>
302. FixedSizeArray<T>& FixedSizeArray<T>::operator=(const FixedSizeArray<T>& other)
303. {
304.    // Сперва проверяется, может объект был приравнен к самому себе, как например
305.    //
306.    // FixedSizeArray<int> fsArr(10, -5);
307.    // fsArr = fsArr;
308.    //
309.    // И если так, то ничего делать не надо, просто возвращаем *this.
310.    if (this == &other)
311.       return *this;
312.    ~FixedSizeArray<T>(); // Далее стирается массив объекта слева от знака равно при помощи вызова деструктора.
313. 
314.    // Как уже было сказано: this - это указатель на объект, для которого был вызван данный метод.
315.    // Пусть ptr - указатель на объект класса, у которого есть мембер-переменная val, тогда
316.    // запись ptr->val эквивалентна записи (*ptr).val. То есть если хотим обратиться к переменной val
317.    // через указатель, вместо точки используем стрелку ->.
318.    // Точно так же с функциями: если ptr - указатель на объект класса, у которого есть мембер-функция f(), тогда
319.    // её можно вызвать через указатель, если написать ptr->f().
320.    // Снизу запись this->m_arr и this->m_size абсолютно эквивалентны записям m_arr и m_size. Написано всё так
321.    // чисто ради иллюстрации ключевого слова this и операции стрелочки.
322.    this->m_arr = new T[other.m_size]{}; // создается новый массив.
323.    for (std::size_t i = 0; i < other.m_size; ++i)
324.    {
325.       this->m_arr[i] = other.m_arr[i]; // каждый элемент массива other копируется в массив this.
326.    }
327.    this->m_size = other.m_size; // копируется size.
328. 
329.    return *this; // возвращается объект данного класса.
330. }
331. 
332. // Рассмотрим move-assignment operator
333. template <typename T>
334. FixedSizeArray<T>& FixedSizeArray<T>::operator=(FixedSizeArray<T>&& other)
335. {
336.    // Начинается всё так же, как и в assignment операторе.
337.    if (this == &other)
338.       return *this;
339.    ~FixedSizeArray<T>();
340. 
341.    // Далее копируется адрес на массив объекта other.
342.    this->m_arr = other.m_arr;
343.    // Адрес объекта other стирается, чтобы не происходило бы двойного удаления.
344.    other.m_arr = nullptr;
345.    // Копируется размер.
346.    this->m_size = other.m_size;
347. 
348.    // Возвращается референс на объект слева от знака =.
349.    return *this;
350. }
351. 
352. // Также рассмотрим деструктор
353. template <typename T>
354. FixedSizeArray<T>::~FixedSizeArray()
355. {
356.    // ------->[ВОПРОС] A не нужно ли проверять, является ли m_arr пустым при удалении? Ведь на 344-й строке
357.    //                  указатель m_arr приравнивается к nullptr.
358.    // Ответ: Не нужно. Всё из-за того, что в стандарте C++ указано, что использование команды delete или delete[] на указателе,
359.    //        который указывает на nullptr, является безопасной операцией и просто ничего не делает.
360.    delete[] m_arr;
361. }
362. 
363. template <typename T>
364. FixedSizeArray<T>::FixedSizeArray(std::size_t size)
365.    : m_arr(new T[size]{})
366.    , m_size(size)
367. {
368. }
369. 
370. template <typename T>
371. FixedSizeArray<T>::FixedSizeArray(std::size_t size, T val)
372.    : m_arr(new T[size])
373.    , m_size(size)
374. {
375.    for (std::size_t i = 0; i < size; ++i)
376.    {
377.       m_arr[i] = val;
378.    }
379. }
380. 
381. template <typename T>
382. FixedSizeArray<T>::FixedSizeArray(const FixedSizeArray& other)
383.    : m_arr(new T[other.m_size])
384.    , m_size(other.m_size)
385. {
386.    for (std::size_t i = 0; i < m_size; ++i)
387.    {
388.       m_arr[i] = other[i];
389.    }
390. }
391. 
392. template <typename T>
393. T& FixedSizeArray<T>::operator[](std::size_t index)
394. {
395.    return m_arr[index];
396. }
397. 
398. template <typename T>
399. const T& FixedSizeArray<T>::operator[](std::size_t index) const
400. {
401.    return m_arr[index];
402. }
```

