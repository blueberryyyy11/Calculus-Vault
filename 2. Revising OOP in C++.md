##### 2. Revising OOP in C++, struct, Member variables and member functions, default constructors, constructors withparameters, operator overloading.

OOP is a programming paradigm that uses objects and classes to model real-world problems. It includes the following core principles:

1. **Encapsulation**:
*(если спросят на интервью)*
Это возможность модифицировать доступ к свойствам ваших классов.

*(исходное определение)*
Инкапсуляция позволяет хранить данные и функции, которые работают с этими данными в одной структуре, которая называется классом.

2. **Inheritance**:
Это передача свойств одного класса другому.

*пример*:
```cpp
class Base {
public:
	int x;
};

class Derived : public Base {
public:
	void show() { std::cout << x; }
};
```

3. **Polymorphism**:
*(в языке)*
Это когда две отдельные сущности имеют одно и то же имя.
*нпр*: hot (горячо/остро)

*(в с++)*
Полиморфизм разделяется на два типа:

° **статичный**: происходит compile time
*нпр*: перегрузка функций, шаблоны
° **динамичный**: runtime решается какая из функций с одинаковым именем вызывается.
*нпр*:
```cpp
class Base {
public:
	virtual void print() { std::cout << "Base"; }
};
class Derived : public Base {
	public:void print() override { std::cout << "Derived"; }
};
```

4. **Abstraction:**
Это рассмотрение тех свойств субъекта, которые важны при решении задачи, и отбрасывание остальных свойств.

*Пример абстракции*:
Вы пользуетесь телефоном, зная его функционал (звонки, камера), но не думаете о том, как он устроен внутри.
В C++ абстракция реализуется через:
1. Классы и объекты.
2. Интерфейсы (абстрактные классы).
3. Виртуальные функции и полиморфизм.

*Абстрактный класс* — это класс, который содержит хотя бы одну чисто виртуальную функцию.
- <font color="#953734">нельзя</font> создать объект этого класса
- но они могут использоваться как <font color="#953734">базовые классы </font>для наследования

```cpp
#include <iostream>
class Shape {
public:
	virtual void draw() const = 0; // Чисто виртуальная функция
};
class Circle : public Shape {
public:
	void draw() const override {
		std::cout << "Drawing Circle\n";
	}
};
class Rectangle : public Shape {
public:
	void draw() const override {
		std::cout << "Drawing Rectangle\n";
	}
};
```

> ***Виртуальная функция*** — это функция, объявленная в базовом классе с ключевым словом virtual , которая может быть переопределена в производных классах. Она позволяет реализовать полиморфизм (динамическое связывание).

Если базовый класс *имеет* виртуальную функцию, вызов функции через указатель/ссылку на базовый класс будет вызывать реализацию из производного класса.
Если функция *не переопределена*, используется реализация из базового класса.

```cpp
#include <iostream>
class Base {
public:
	virtual void show() const {std::cout << "Base show\n";}
};

class Derived : public Base {
public:
	void show() const override {
		std::cout << "Derived show\n";
	}
};

int main() {
	Base* basePtr;
	Derived d;
	basePtr = &d;
	basePtr->show(); // Вывод: Derived show (динамическое связывание)
	
	return 0;
}
```

---
ниже написано structs+operators.cpp (в текстовом формате)

# Structs in C++

Структура представляет собой множество данных (называемых **полями структуры**) и множество функций (называемых **member functions** или **методами структуры**), которые работают с этими данными.

## Пример структуры:
```cpp
struct Complex {
    double re;
    double im;
};
```

## Поля структуры
После объявления структуры, например, в `main`:
```cpp
Complex z;
```

По сути, мы объявляем сразу две переменные: `z.re` и `z.im`. С ними можно выполнять те же действия, что и с переменными типа `double`. Например:

```cpp
int main() {
    Complex z;
    z.re = 5.23;
    z.im = z.re - 2;
    std::cout << z.re << " " << z.im;
    return 0;
}
```

Переменные типа структуры называются **объектами** (например, `z` — объект).

---

## Методы структуры

Методы — это функции, которые работают с полями структуры.

### Пример метода:
```cpp
double abs() const {
    return std::sqrt(re * re + im * im);
}
```

Данная функция вычисляет абсолютное значение комплексного числа. Вызывать метод можно через объект структуры, например:

```cpp
z.abs();
```

### Примечание:
Ключевое слово `const` указывает, что данный метод не изменяет поля структуры (`re` и `im` остаются неизменными). Если метод не был бы `const`, его нельзя было бы вызвать для константного объекта.

Пример:
```cpp
void printAbs(const Complex& complex) {
    std::cout << complex.abs();
}
```

Код выше **не скомпилировался бы**, если бы метод `abs` не был объявлен с модификатором `const` (так как ссылка на объект `complex` является константной).

---

### Еще один метод:
```cpp
void add_real(double real) {
    re += real;
}
```

Данная функция добавляет к вещественной части нашего комплексного числа некоторое число `real`. Вызывать метод можно через объект, например:

```cpp
z.add_real(3.14);
```

### Примечание:
Данный метод **не может** быть объявлен как `const`, потому что он изменяет состояние полей структуры. Если попытаться написать метод следующим образом:

```cpp
void add_real(double real) const {
    re += real; // Ошибка: изменение состояния запрещено.
}
```

Код не скомпилируется, так как метод изменяет значение поля `re`.



-------------------------- ***Конструкторы:*** ---------------------------

**Конструктор** - это функция, у которого нету возвращаемого типа (даже void), а имя совпадает с именем самой структуры.  
Конструктор вызывается при создании объекта.

Например:
// конструктор (1)
```cpp
Complex(double real_part) {
    re = real_part;
    im = 0;
}
```

Чтобы вызвать данный конструктор, необходимо при инициализации объекта передать вещественное число.

Например:
```cpp
int main() {
    Complex z1(23.5); // вызовется конструктор(1) и будет создан объект z1 с полем re = 23.5, im = 0.
    Complex z2 = -2.4; // вызовется конструктор(1) и будет создан объект z2 с полем re = -2.4, im = 0.
}
```

**ЗАМЕЧАНИЕ 1:**  
Если рядом с объявлением конструктора написать ключевое слово `explicit`, т. е.  
`explicit Complex(double real_part)`, то `Complex z2 = -2.4` не скомпилируется.  
Данная запись нужна, если мы хотим вызывать конструктор лишь явным образом, а в `Complex z2 = -2.4` она вызвана неявно.

**ЗАМЕЧАНИЕ 2:**  
Одновременно может существовать несколько конструкторов, если они отличаются аргументами.  
Например, наряду с конструктором (1) можно объявить другой конструктор:  

// конструктор (2)
```cpp
Complex(double real_part, double imaginary_part) {
    re = real_part;
    im = imaginary_part;
}
```

Конструктор 2 вызовется, если передать при создании объекта сразу 2 вещественных числа.

Например:
```cpp
int main() {
    Complex z1(23.5); // вызовется конструктор(1) и будет создан объект z1 с полем re = 23.5, im = 0.
    Complex z2(-2.4, 9.5); // вызовется конструктор(2) и будет создан объект z2 с полем re = -2.4, im = 9.5.
}
```


-------------------- ***Конструктор по умолчанию:*** -------------------

Конструктор, который не получает никаких аргументов, называется **конструктором по умолчанию** (default constructor).  

Например:
// конструктор (3)
```cpp
Complex() {
    re = 0;
    im = 0;
}
```

Данный конструктор вызывается, если при создании объекта аргументов передано не было.

Пример:
```cpp
int main() {
    Complex z;
}
```

**ЗАМЕЧАНИЕ 1:**  
Если в структуре нет никаких конструкторов, то компилятор генерирует собственный конструктор по умолчанию.

**ЗАМЕЧАНИЕ 2:**  
Если в структуре присутствует хоть один конструктор, то конструктор по умолчанию не генерируется.  
Например, если объявить лишь конструкторы (1) и (2), то `Complex z` не скомпилируется.  

В ином случае, если никаких конструкторов не объявлено, то компиляция пройдет успешно.

**ЗАМЕЧАНИЕ 3:**  
Конструкторы (1), (2) и (3) можно объединить в один:

// конструктор (4)
```cpp
Complex(double real_part = 0, double imaginary_part = 0) {
    re = real_part;
    im = imaginary_part;
}
```



----------------------- ***Member initialization:*** ------------------------
// конструктор (5)
```cpp
Complex(double real_part = 0, double imaginary_part = 0)
    : re(real_part)
    , im(imaginary_part)
{}
```

Данная запись отличается от конструктора (4) тем, что значения переменным `re` и `im` в (4) задаются уже после их создания.  
То, что происходит в конструкторе (4), эквивалентно следующему:
```cpp
double re;
double im;
re = real_part;
im = imaginary_part;
```
А в конструкторе (5) происходит следующее:
```cpp
double re = real_part;
double im = imaginary_part;
```
Т.е. значения в этом случае задаются при создании `re` и `im`.


---------------------- ***Перегрузка операторов:*** ----------------------
Легко заметить, что если объявить лишь вышеуказанные методы, следующая запись не будет компилироваться:
```cpp
int main() {
    Complex z1(23.5);
    Complex z2(-2.4, 9.5);
    z1 += z2;
}
```

Связано это с тем, что операция `+=` неопределена для нашей структуры. Чтобы эту операцию определить, необходимо перегрузить оператор `+=`. 

Оператор перегружается определением метода с названием `operator+=`, который получает 1 аргумент — второе комплексное число.

Перегрузить можно следующим образом:
```cpp
void operator+=(const Complex& other) {
    re += other.re;
    im += other.im;
}
```

Теперь `z1 += z2;` будет вызывать оператор `+=`, а запись `z1 += z2;` эквивалентна `z1.operator+=(z2)`.

**ЗАМЕЧАНИЕ 1:**  
На удивление, следующая запись:
```cpp
int main() {
    Complex z(-2.4, 9.5);
    z += 3.14;
}
```
скомпилируется.  

Заметим, что `z += 3.14;` эквивалентно `z.operator+=(3.14);`.  
Хоть у нас `operator+=` не принимает значение типа `double`,  
`z += 3.14` сперва вызовет конструктор (5), и оператору `+=` будет передан `other` с полями `re=3.14` и `im=0`.

**ЗАМЕЧАНИЕ 2:**  
Заметим, что для обычных чисел (например, для `int`):
```cpp
int x = 10;
int y = 20;
```
у выражения `x += y;` кроме побочного эффекта есть также значение — `30`.  
Действительно, запись `std::cout << (x += y);` выведет `30`, т.е. значение `x` после прибавления `y`.  

Если же `x` и `y` — комплексные, то `x += y` вызовет функцию `operator+=`, а возвращает она `void`.  
Т.е. если `x` и `y` комплексные, то для `x += y` значения нет (что очень плохо).

Таким образом, чтобы решить данный вопрос, необходимо, чтобы метод `operator+=` возвращал бы комплексное число — сам объект, `operator+=` которого был вызван. Т.е. значение записи `z1 += z2` должно равняться значению `z1` после сложения.

Приходим к записи:
```cpp
Complex operator+=(const Complex& other) {
    re += other.re;
    im += other.im;
    return *this;
}
```

Тут `*this` — это объект, для которого вызвалась функция `operator+=`.  
Например, при записи `z1 += z2`, т.е. `z1.operator+=(z2)`,  
`*this` — это объект `z1`.

**ЗАМЕЧАНИЕ 3:**  
Оператору `+=` стоит возвращать ссылку на `Complex`, как указано ниже:
```cpp
Complex& operator+=(const Complex& other) {
    re += other.re;
    im += other.im;
    return *this;
}
```

Запись `Complex&` тут по двум причинам:
1. Чтобы `*this` не копировался.
2. Так как для обычных чисел запись `x += y` является ссылкой для `x`. 
   Например, в записи:
   ```cpp
   int main() {
       int x = 10;
       int y = 20;
       (x += y) = -7;
   }
   ```
   значение `x` будет изменено на `-7`.

---

Аналогично определяются другие операторы:
```cpp
Complex& operator+=(const Complex& other) {
    re += other.re;
    im += other.im;
    return *this;
}

Complex& operator-=(const Complex& other) {
    re -= other.re;
    im -= other.im;
    return *this;
}

Complex& operator*=(const Complex& other) {
    re = re * other.re - im * other.im;
    im = re * other.im + im * other.re;
    return *this;
}

Complex& operator/=(const Complex& other) {
    // сделай сам
    return *this;
}
```



------------------------ ***Другие операторы***: -----------------------
Рассмотрим перегрузку оператора +
```cpp
Complex operator+(const Complex& other) {
    Complex result;
    result.re = re + other.re;
    result.im = im + other.im;
    return result;
}
```

**ЗАМЕЧАНИЕ 1:**  
`operator+` возвращает уже не ссылку, а результат в виде объекта. Делается это из технических соображений, так как `result` есть временная переменная (можно было также записать вместо возвращаемого типа `const Complex&`).

**ЗАМЕЧАНИЕ 2:**  
Данный `operator+` МОЖЕТ быть вызван следующими способами:

**Способ 1:**
```cpp
int main() {
    Complex z1(23.5);
    Complex z2(-2.4, 9.5);
    Complex sum = z1 + z2;
}
```

**Способ 2:**
```cpp
int main() {
    Complex z(-2.4, 9.5);
    Complex sum = z + 3.1;
}
```

При первом способе запись `z1 + z2;` эквивалентна `z1.operator+(z2);`.  
Во втором способе запись `z1 + 3.1;` эквивалентна `z1.operator+(3.1);` (см. `operator+=`, чтобы понять, почему это работает).

**ЗАМЕЧАНИЕ 3:**  
Данный `operator+` НЕ МОЖЕТ быть вызван следующим способом:

**Способ 3:**
```cpp
int main() {
    Complex z(-2.4, 9.5);
    Complex sum = 4 + z;
}
```

Так как запись `4.operator+(z)` не имеет смысла.  
Чтобы запись `Complex sum = 4 + z;` скомпилировалась, необходимо `operator+` убрать из структуры, как это сделано ниже.


--------------------- ***Операторы вне структуры:*** --------------------
Как было указано в замечании 3 для других операторов, `operator+` стоит определить вне структуры.  

Делается это следующим образом:
```cpp
Complex operator+(const Complex& lhs, const Complex& rhs) {
    Complex result;
    result = lhs.re + rhs.re;
    result = lhs.im + rhs.im;
    return result;
}
```

Данная запись позволяет вызвать оператор `+` как Способами 1-2, так и Способом 3.  
Способ 3 работает из-за следующей причины: Если компиляция `4.operator+(z)` не пройдет, компилятор на строке `[Complex sum = 4 + z]` попытается скомпилировать `operator+(4, z)`, а данная компиляция пройдет, так как для `4` есть конструктор (см. `operator+=`).

Но есть более элегантный способ записи данной функции, где используется уже определенный оператор `+=`, указанный ниже:
```cpp
Complex operator+(Complex lhs, const Complex& rhs) {
    return lhs += rhs;
}

Complex operator-(Complex lhs, const Complex& rhs) {
    return lhs -= rhs;
}

Complex operator*(Complex lhs, const Complex& rhs) {
    return lhs *= rhs;
}

Complex operator/(Complex lhs, const Complex& rhs) {
    return lhs /= rhs;
}
```

------------------------ ***Операторы << и >>:*** ------------------------

Рассмотрим код:
```cpp
int main() {
    Complex z(-2.4, 9.5);
    std::cout << z;
}
```

Легко можно понять: для того, чтобы запись `[std::cout << z]` скомпилировалась, компилятор будет сперва пытаться скомпилировать `[std::cout.operator<<(z)]`.  
`std::cout` также является объектом (а именно — объектом, приводящимся к типу `std::ostream&`).  
`std::ostream` — другая структура. Разумеется, в этой структуре нет оператора `<<`, который принимал бы значение типа `Complex`.

Таким образом, так как `operator<<` нельзя определить внутри структуры `std::ostream`, его нужно определить вне:
```cpp
std::ostream& operator<<(std::ostream& out, const Complex& complex) {
    out << "(" << complex.re << ", " << complex.im << ")";
    return out;
}
```

Таким образом, в строке `[std::cout << z;]` будет вызван `operator<<(std::cout, z)`.

**ЗАМЕЧАНИЕ 1:**  
Заметьте, что переменную `out` функция получает через ссылку. Связано это с тем, что сам объект `std::cout` меняет состояние своего поля после записи `std::cout << z;` (меняет место маркера в консоли).

**ЗАМЕЧАНИЕ 2:**  
Нижеприведенный код:
```cpp
int main() {
    Complex z(-2.4, 9.5);
    std::cout << z << " is a great complex number!";
}
```
не скомпилируется, так как запись в строке `[std::cout << z << " is a great complex number!";]` эквивалентна `operator<<(std::cout, z) << " is a great complex number!";`.  
А `operator<<` возвращает `void`, и, конечно, запись `void << " is a great complex number!";` не имеет смысла.  

Поэтому данная функция должна возвращать сам объект `out`:
```cpp
std::ostream& operator<<(std::ostream& out, const Complex& complex) {
    out << "(" << complex.re << ", " << complex.im << ")";
    return out;
}
```

`std::cin` же является объектом, приводящимся к типу `std::istream&`.  

Зная это, обеспечьте компиляцию следующего кода:
```cpp
int main() {
    Complex z;
    std::cin >> z;
}
```