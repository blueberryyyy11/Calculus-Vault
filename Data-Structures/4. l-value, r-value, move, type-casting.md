##### 4. l-value/r-value references, std::move, move constructor, move assignment operator, Type casting in c++: static_cast, reinterpret_cast, const_cast

### Работа со ссылками (references) и константными ссылками (const references)
```cpp
// Функция демонстрирует работу со ссылками (references)
// и константными ссылками (const references).
void references_and_const_references()
{
    // Инициализируем переменную x значением 19
    int x = 19;
    // Создаём копию x в переменной copy.
    // Это отдельная переменная со своим значением.
    int copy = x;
    // Создаём ссылку ref, которая "привязана" к x.
    // Теперь любое изменение через ref затронет x.
    int& ref = x;
    // Изменяем значение copy:
    // Поскольку copy — это отдельная переменная, это НЕ повлияет на x.
    copy = 777;
    std::cout << x << "\n";
    // Вывод: 19 (так как x по-прежнему равен 19)
    // Изменяем x через ссылку ref:
    // Поскольку ref ссылается на x, его изменение напрямую меняет x.
    ref = 777;
    std::cout << x << "\n";
    // Вывод: 777 (теперь x равно 777)
    // Создаём константу и константную ссылку на неё.
    // constantInteger — это неизменяемая переменная.
    const int constantInteger = 7;
    const int& constantReference = constantInteger;
    // Создаём константную ссылку на обычную переменную x.
    // Через constantReference2 мы не можем изменить x.
    const int& constantReference2 = x;
    // Создаём константную ссылку на временный объект (x + 123).
    // При этом временный объект "продлевает" своё время жизни
    // до конца области видимости constantReference3.
    const int& constantReference3 = x + 123;
}
```

### Работа со строками (std::string)
```cpp
// Функция принимает std::string по значению (создаётся копия строки).
void print(std::string str)
{
    std::cout << str;
}

// Функция принимает std::string по неконстантной ссылке.
// Можно изменять переданную строку внутри функции.
void print1(std::string& str)
{
    std::cout << str;
}

// Функция принимает std::string по константной ссылке.
// Копия не создаётся, но исходная строка не может быть изменена внутри функции.
void print2(const std::string& str)
{
    std::cout << str;
}
```

### Замечания:
1. Неконстантный референс можно создать исключительно на неконстантное `l-value` выражение того же типа.
2. Нельзя создать референс без значения. Например, нельзя просто написать `int& ref;`.
3. Как только референс создан на одну переменную, нельзя сделать так, чтобы референс ссылался бы на другую переменную.


## r-value референс
```cpp
1. ﻿#include <iostream>
2. 
3. // В данной функции объясняется что такое r-value референс.
4. void r_value_reference()
5. {
6.    // Будет использовано позже.
7.    int x = 10;
8. 
9.    // Те референсы, которые были обсуждены в файле References.cpp называются l-value референсами
10.    // и они присутствовали в C++ с самого начала его существования.
11.    // 
12.    // Называются они l-value референсами так как неконстантные референсы могут ссылаться лишь на
13.    // l-value выражения. Но как мы уже поняли есть потребность создавать функции,
14.    // которые получали бы l-value значения по-ссылке (чтобь избежат копирования),
15.    // но могли бы также получать r-value значения (см. функцию print2 в References.cpp).
16.    // Именно по-этому было решено разрешать присваивать константным ссылкам как l-value, так и r-value значения.
17.    //
18.    // Но что если по каким-то причинам мы хотим создать отдельно 2 функции с одним и тем же именем,
19.    // так, чтобы первая из них вызывалась бы если было передано l-value значение, а вторая вызывалась
20.    // бы, если было передано r-value значение?
21.    //
22.    // Как раз для этого случая существуют r-value референсы, которые были добавлены в C++11,
23.    // их синтаксис следующий:
24.    // 
25.    // <тип>&& <название референса> = <r-value значение>;
26.    //
27.    // Например:
28.    int&& r_value_ref = x + 1;
29. 
30.    // Замечания:
31.    // 1. r-value референс может ссылаться лишь на r-value значение (удлинняя жизнь временной переменной).
32.    //    т.е. запись int&& ref=x; привела бы к ошибке компиляции, так как х - l-value.
33.    // 2. r-value референсы как и l-value референсы должны быть инициализированны, т.е. нельзя писать
34.    //    int&& ref; <---- Ошибка компиляции.
35. 
36.    // --------->[ВОПРОС] Как уже было сказано r-value референс может ссылаться лишь на r-value значение,
37.    //                    но сам этот референс представляет из себя нечто l-value или r-value?
38.    //                    То есть может ли он оказаться слева от знака =?
39.    // Ответ: Так как у r_value_ref есть имя, то оно является l-value, как уже было сказано в References.cpp
40.    // Подытожив: r_value_ref может ссылаться лишь на r-value значение, но сам r_value_ref - l-value.
41.    // Пример: Можно менять значение r-value референса
42.    r_value_ref = 19;
43.    ++r_value_ref;
44.    r_value_ref /= 10;
45. 
46.    // Замечание: Значение константных r-value референсов поменять нельзя и ссылаться они могут
47.    //            лишь на r-value выражения. Пример:
48.    const int&& const_r_value_ref = 10 / x + 3 - r_value_ref;
49. 
50.    // --------->[ВОПРОС] На что могут ссылаться константные/неконстантные l-value/r-value референсы?
51.    // Ответ: Смотри таблицу
52.    //
53.    //                      |           non-const               |                const                |
54.    //   -------------------|-----------------------------------|-------------------------------------|
55.    //    l-value reference | only non-const l-value expression | any l-value and r-value expression  |
56.    //   -------------------|-----------------------------------|-------------------------------------|
57.    //    r-value reference |     only r-value expression       |      only r-value expression        | 
58.    //   -------------------|-----------------------------------|-------------------------------------|
59.    //
60. }
61. 
62. // Далее приводятся примеры функций, принимающих l-value и r-value референсы.
63. 
64. void f(int& x) // принимает неконстантный l-value референс.
65. {
66.    std::cout << "x was l-value\n";
67. }
68. 
69. void f(int&& x) // принимает неконстантный r-value референс.
70. {
71.    std::cout << "x was r-value\n";
72. }
73. 
74. // Теперь, если написать:
75. // 
76. // int main()
77. // {
78. //    int var = 17;
79. //    f(var);
80. //    f(var + 1);
81. //    f(777);
82. // }
83. //
84. // То на 79-ой строке вызовется первая функция,
85. // а на 80-ой и 81-ой строке вызовется вторая и будет напечатано
86. //
87. // x was l-value
88. // x was r-value
89. // x was r-value
90. //
91. // Всё из-за того, что
92. // 1. На 79-ой строке аргумент переданный функции является l-value и будет вызвана первая функция
93. // 2. На 80-ой строке аргумент переданный функции является r-value и будет вызвана вторая функция
94. // 3. На 81-ой строке аргумент переданный функции является r-value и будет вызвана вторая функция
95. //
96. 
97. // Другой пример с константным l-value референсом:
98. void g(const int& x) // принимает константный l-value референс.
99. {
100.    std::cout << "x was l-value\n";
101. }
102. 
103. void g(int&& x)      // принимает неконстантный r-value референс.
104. {
105.    std::cout << "x was r-value\n";
106. }
107. 
108. // Теперь, если написать:
109. // 
110. // int main()
111. // {
112. //    int var = 17;
113. //    g(var);
114. //    g(var + 1);
115. //    g(777);
116. // }
117. //
118. // ------->[ВОПРОС]: И первая и вторая функция могут принимать r-value значения,
119. //                   Так какая из них вызовется на 114-ой и 115-ой строках?
120. // Ответ: Как ни странно - приоритет получения r-value значений дается именно r-value референсам.
121. //        Таким образом мы увидим тот же результат, что и для f:
122. // 
123. //        x was l-value
124. //        x was r-value
125. //        x was r-value
126. //
127. // ------->[ВОПРОС]: Чем отличаются функции g и f?
128. // Ответ: Нельзя передать f константную переменную, например
129. //      
130. //        const int val = 777;
131. //        f(val);
132. //
133. //        Не скомпилируется, так как
134. //        1. f на 64-ой принимает неконстантную ссылку, следовательно нельзя передать константное.
135. //        2. f на 69-ой строке принимает r-value референс, следовательно нельзя передать l-value.
136. //        а val константное l-value значение.
137. //
138. //        С другой стороны f можно поменять на g в 131-ой строке и компиляция пройдет.
139. // 
140. // ------->[ВОПРОС]: Что изменилось бы если в 69-ой и 103-ей строках r-value референсы были константными, т.е.
141. //                   void f(const int&& x)
142. //                   void g(const int&& x)
143. // Ответ: Всё что было сказано до этого не изменилось бы. Единственное отличие было бы в том,
144. //        что внутри самих функций x нельзя было бы поменять.
145. 
146. // ------->[САМЫЙ ВАЖНЫЙ ВОПРОС]: Для чего это всё нужно?
147. // Ответ: Нужно всё для того, чтобы изменить поведение функции в зависимости от того было ли
148. //        переданно данной функции l-value или r-value, а надобность этого будет понятна
149. //        после прочтения MoveSemantics.cpp.

```

MoveSemantics.cpp
```cpp
1. ﻿#include <iostream>
2. #include <utility>
3. #include <string>
4. 
5. // В данном файле мы поверхностно поймем, что такое move-семантика.
6. 
7. // Рассмотрим следующий сценарий: Есть функция, которая принимает std::string по значению
8. void f(std::string str)
9. {
10.    // какие-то действия с str.
11. }
12. 
13. // Заметим, что при следующей передаче переменной функции
14. //
15. // int main()
16. // {
17. //    std::string name="Barak Obama";
18. //    f(name);
19. // }
20. //  
21. // Переменная name будет скопирована в str.
22. /*
23.    Подытожим: В 17ой строке будет создана переменная name
24.     _______________
25.    |     name      |
26.    |---------------|
27.    | "Barak Obama" |
28.     ---------------
29. 
30.     А в 18ой строке name будет скопирован в str функции f и будем иметь
31.     _______________         _______________
32.    |     name      |       |      str      |
33.    |---------------|       |---------------|
34.    | "Barak Obama" |       | "Barak Obama" |
35.     ---------------         ---------------
36. */
37. //
38. // -------->[ВОПРОС] А что делать если переменная name нам в main уже ненужна?
39. //                   Ведь тогда логично было бы не создавать копию name, а просто "передать"?
40. // Ответ: Если функцию f изменить нельзя - как раз для этого используется std::move.
41. //        Если написать
42. // 
43. //        int main()
44. //        {
45. //           std::string name="Barak Obama";
46. //           f(std::move(name));
47. //        }
48. //
49. //        тогда name не будет скопирован в str, а будет "сдвинут" str.
50. //
51. /*
52.    Подытожим: В 45ой строке будет создана переменная name
53.     _______________
54.    |     name      |
55.    |---------------|
56.    | "Barak Obama" |
57.     ---------------
58. 
59.     А в 46ой строке значение name будет мувнуто в str
60.     _________________         _______________
61.    |       name      |       |      str      |
62.    |-----------------|       |---------------|
63.    | пустое значение |       | "Barak Obama" |
64.     -----------------         ---------------
65. */
66. // Таким образом значение name не будет скопировано, но будет использоваться в str.
67. // Для ясности: "Barak Obama" сохраняется при помощи указателя и вместо того,
68. //              чтобы скопировать саму строку - копируется лишь указатель, а старый указатель
69. //              стирается, то есть:
70. // 1. Сперва создается переменная name
71. /*
72.     ______
73.    | name |
74.    |------|
75.    |   -----------------> "Barak Obama"   
76.     ------
77. 
78.     2. При создании переменной str копируется лишь адрес строки, а указатель в name стирается
79. 
80.                          _____
81.                         | str |
82.                         |-----|
83.                         |  |  |
84.                          --|--
85.                            |
86.                            |
87.     ______                 |
88.    | name |                |
89.    |------|                v
90.    |      |               "Barak Obama"
91.     ------
92. */
93. // ---------->[ЗАМЕЧАНИЕ] После std::move переменной name пользоваться нельзя, непонятно какое значение
94. //                        внутри name, что приводит к undefined behavior.
95. 
96. // Поймём как работает std::move.
97. 
98. // Снова вернемся к примеру из R-valueReferences.cpp
99. void g(const int& x) // принимает константный l-value референс.
100. {
101.    std::cout << "x was l-value\n";
102. }
103. 
104. void g(int&& x)      // принимает неконстантный r-value референс.
105. {
106.    std::cout << "x was r-value\n";
107. }
108. // ------>[ВОПРОС] Что если у нас есть переменная int val=555; и мы хотим передать его
109. //                 функции g, но хотим, чтобы вызвалась не функция на строке 99, а на 104?
110. //                 Причем мы не хотим менять сами функции.
111. // Очень Странный Ответ: Использовать std::move, а именно
112. //
113. //        int val = 555;
114. //        g(std::move(val)); // напечатает "x was r-value"
115. // 
116. // ------>[ВОПРОС] Что же делает std::move? Почему это работает так?
117. // Ответ: Единственная функция std::move - полученное l-value значение преобразовать в r-value.
118. //        Как раз поэтому на строке 114 вызовется функция с строки 104, хоть val и l-value.
119. //
120. // ------>[ВОПРОС] А как же тогда всё работает для std::move(name) из строки 46?
121. // Ответ: std::string имеет 2 конструктора. Первый из них - это copy-constructor, который принимает l-value reference.
122. //        
123. //        string(const string& other);
124. //
125. //        Данный конструктор копирует всю строку other в создаваемый объект.
126. //        Второй же конструктор принимает r-value reference.
127. //
128. //        string(string&& other);
129. //
130. //        И копирует лишь указатель строки other в создаваемый объект, далее стирает указатель other (именно поэтому тут не const).
131. //        
132. //        Таким образом, вернувшись к функции f, если переменная была передана ей не используя std::move, т.е.
133. //        int main()
134. //        {
135. //           std::string name="Barak Obama";
136. //           f(name);
137. //        }
138. //        То для name будет вызван copy-constructor, так как name l-value и вызовется конструктор на строке 123.
139. //
140. //        Если же перед передачей сделать std::move(name), т.е.
141. //        int main()
142. //        {
143. //           std::string name="Barak Obama";
144. //           f(std::move(name));
145. //        }
146. //        Тогда из-за того, что std::move(name) r-value вызовится конструктор, принимающий r-value reference на строке 128.
147. //        Конструктор на строке 128 называется мув конструктором.

```


***Определение*** : `std::move` — это функция, которая преобразует l-value в r-value, позволяя передать временный объект в функции или конструкторы перемещения.


### Конструктор перемещения (move constructor)

***Определение***: Конструктор перемещения позволяет передавать ресурсы (например, динамическую память) от одного объекта к другому без копирования.

*Синтаксис*:
```cpp
class MyClass {
private:
    int* data;

public:
    MyClass(int value) {
        data = new int(value);
    }

    // Конструктор перемещения
    MyClass(MyClass&& other) noexcept : data(other.data) {
        other.data = nullptr; // Обнуляем указатель в исходном объекте
    }

    ~MyClass() {
        delete data;
    }
};
```

-----> ***Особенности***:
 Конструктор перемещения вызывается, если объект передаётся как r-value.
 

### Оператор присваивания с перемещением (move assignment operator)

***Определение***: Оператор перемещающего присваивания используется для переноса ресурсов между объектами.

*Синтаксис*:
```cpp
MyClass& operator=(MyClass&& other) noexcept {
    if (this != &other) {
        delete data;
        data = other.data;
        other.data = nullptr;
    }
    return *this;
}
```

-----> ***Особенности***:
1. Необходимо очищать текущие ресурсы перед переносом.
2. Обеспечивает защиту от самоприсваивания.

---

# Приведение типов в C++ (type casting in c++)

### static_cast

***Определение***: Используется для проверяемого преобразования типов во время компиляции. Преобразует, если существует логическая связь и преобразование не приводит к потери данных.

*Пример*:
```cpp
double d = 3.14;
int i = static_cast<int>(d); // Убрана дробная часть
```

-----> **Особенности:**
- Используется для приведения указателей между базовым и производным классами.


### reinterpret_cast

***Определение***: Это низкоуровневое преобразование, которое не меняет содержимое памяти. Оно просто интерпретирует её как другой тип.

- Используется для небезопасного преобразования типов.
- Если мы уверены, что преобразование не приведёт к undefined behavior, то можем сделать этот каст.

В отличие от других видов приведения (`static_cast`, `const_cast`), `reinterpret_cast` чаще всего используется для низкоуровневых преобразований, связанных с указателями, функциями и значениями.

*Синтаксис:*
```cpp
reinterpret_cast<тип-назначения>(выражение);
```
- `тип-назначения` — это тип, в который нужно преобразовать объект.
- `выражение` — это значение, которое нужно преобразовать.

*Пример*:
```cpp
int* p = reinterpret_cast<int*>(0x1234);
```
После преобразования, `p` становится указателем на память по адресу `0x1234`. Однако сам адрес памяти может быть недействительным или указывать на случайные данные.

-----> **Особенности:**
- Позволяет интерпретировать битовое представление одного типа как другого.
- Используется с осторожностью, так как может привести к неопределённому поведению.


### const_cast
**Что делает const_cast?**
- Убирает или добавляет модификатор `const` (и/или `volatile`) у указателей или ссылок.

*Синтаксис:*
```cpp
const_cast<тип-назначения>(выражение);
```
- `тип-назначения` — это новый тип, который вы хотите получить.
- `выражение` — это значение, которое вы преобразуете.

##### ***Когда использовать?***
При необходимости вызвать функцию, которая ожидает неконстантный параметр, но у вас есть константный объект.

Пример:
```cpp
#include <iostream>

void modify(int& value) {
    value = 100;
}

int main() {
    int x = 42; // Объявлен без const
    const int& ref_x = x; // ref_x имеет квалификатор const
    modify(const_cast<int&>(ref_x)); // Удаление const, корректно
    std::cout << "x = " << x << '\n'; // Вывод: x = 100
    return 0;
}
```
Здесь поведение определено, так как исходный объект `x` не является `const`.

##### ***Когда НЕ использовать?***
Если вы пытаетесь изменить изначально `const` объект — это всегда приводит к неопределённому поведению.

*Пример*:
```cpp
int main() {
    const int x = 42;
    int* p = const_cast<int*>(&x);
    *p = 24; // Неправильное использование (неопределённое поведение)
    std::cout << x << '\n'; // Результат может быть любым
    return 0;
}
```

**Почему UB (неопределённое поведение)?**
Объект `x` изначально объявлен как `const`, и изменение его значения недопустимо.

