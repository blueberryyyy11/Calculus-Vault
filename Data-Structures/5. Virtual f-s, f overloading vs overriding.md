##### 5. Virtual functions, function overloading vs function overriding, usage of virtual functions, examples, pure virtual functions, virtual destructors, exception handling.

## 1. Виртуальные функции (Virtual Functions)

> **Виртуальная функция** в C++ — это функция, объявленная в базовом классе с ключевым словом `virtual`, которая может быть _переопределена_ (overridden) в производном классе.

**Главная особенность**: при вызове такой функции через _указатель или ссылку_ на базовый класс, но фактически указывающий на объект производного класса, будет вызвана _реальная_ (переопределённая) функция из производного класса.

Это механизм _динамического полиморфизма_ (runtime polymorphism): решение о том, какая реализация функции вызывается, происходит во _время выполнения_, а не на этапе компиляции.

[1.1.1 Пример]

```cpp
class Base {
public:
// Виртуальная функция
    virtual void display() {
        std::cout << "Base class" << std::endl;
    }

// Виртуальный деструктор (рассмотрим позже в разделе "Виртуальные деструкторы")
    virtual ~Base() = default;
};

class Derived : public Base {
public:
// Переопределение виртуальной функции
    void display() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    basePtr->display(); // Выведет: "Derived class" (динамический полиморфизм)
    delete basePtr;
    return 0;
}
```

Если бы `display()` *не была объявлена `virtual` в классе `Base`, то вызов `basePtr->display()` _всегда_ вызывал бы метод `Base::display()`, несмотря на то, что `basePtr` указывает на объект `Derived`.

### 1.1.2 Ключевое слово `override`

Начиная с C++11, при переопределении виртуальной функции в производном классе рекомендуется использовать ключевое слово `override`. Оно указывает компилятору, что метод действительно должен переопределять виртуальную функцию из базового класса. Если в базовом классе не было подходящей виртуальной функции с такой же сигнатурой, произойдёт ошибка компиляции (что помогает избежать опечаток и скрытых ошибок).

```cpp
class Derived : public Base {
public:
    void display() override { // override даёт дополнительную проверку от компилятора
        std::cout << "Derived class" << std::endl;
    }
};
```

### 1.1.3 Ключевое слово `final`

Если нужно запретить дальнейшее переопределение виртуальной функции в классах-наследниках, можно использовать ключевое слово `final`:

```cpp
class Derived : public Base {
public:
    void display() override final {
        std::cout << "Derived class" << std::endl;
    }
};

class MoreDerived : public Derived {
public:
    // Ошибка! display() объявлен как final в классе Derived
    void display() override {
        std::cout << "MoreDerived class" << std::endl;
    }
};

```

Также ключевое слово `final` можно применять к самому классу, чтобы запретить от него наследоваться.

## 2. Перегрузка функций (Function Overloading) vs Переопределение функций (Function Overriding)

### 2.1 Перегрузка функций (Function Overloading)

> **Определение**: Перегрузка — это механизм, при котором в _одном и том же классе_ (или в одной области видимости) можно объявить несколько функций с одним именем, _но разным списком параметров_ (типы, количество, порядок).

- **Когда происходит выбор**: Во _время компиляции_ (compile-time).
- **Цель**: Удобство использования одного и того же «имени операции», но с разными типами данных.

[Пример]

```cpp
void print(int i) {
    std::cout << "Integer: " << i << std::endl;
}

void print(double d) {
    std::cout << "Double: " << d << std::endl;
}

void print(std::string s) {
    std::cout << "String: " << s << std::endl;
}

```

Здесь три функции `print`, которые отличаются набором параметров. Компилятор по типу аргументов в момент вызова решает, какую функцию вызвать.

#### Особенности перегрузки

- Параметры должны различаться по **типам**, **количеству** или **порядку**.
- Возвращаемый тип **не** участвует в выборе перегруженной функции.
- Это **статический полиморфизм** (compile-time polymorphism).

## 2.2 Переопределение функций (Function Overriding)

> **Определение**: Переопределение (overriding) — это механизм, при котором _производный класс_ предоставляет _новую реализацию_ виртуальной функции, объявленной в _базовом классе_.

- **Когда происходит выбор**: Во _время выполнения_ (runtime), если вызов идёт через указатель/ссылку на базовый класс. (`Base* basePtr = new Derived(); basePtr->display()`)
- **Цель**: Реализовать полиморфизм; предоставить уникальное поведение для разных типов, имеющих общий интерфейс.

[Пример]

```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base show\n";
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived show\n";
    }
};

```

#### Отличие от перегрузки

- **Перегрузка** (overloading) — несколько функций **в одном классе** с одним именем, но **разными параметрами** (compile-time).
- **Переопределение** (overriding) — одна и та же функция (по сигнатуре) в базовом и производном классе, с ключевым словом `virtual` в базовом классе (runtime).

## 3. Использование виртуальных функций

Виртуальные функции применяются:

1. _Для организации общего интерфейса_ в базовом классе, с разными реализациями в производных классах.
2. _Для хранения и обработки объектов разнородных типов_ (но с общей базой) в _контейнерах_, используя динамический полиморфизм.

[Небольшой пример с «животными», где у каждого животного свой звук]

```cpp
class Animal {
public:
    virtual void sound() {
        std::cout << "Some generic animal sound\n";
    }

    virtual ~Animal() = default; // виртуальный деструктор
};

class Dog : public Animal {
public:
    void sound() override {
        std::cout << "Woof!\n";
    }
};

class Cat : public Animal {
public:
    void sound() override {
        std::cout << "Meow!\n";
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->sound(); // Woof!
    a2->sound(); // Meow!

    delete a1;
    delete a2;
    return 0;
}

```

Если бы не было виртуальной функции, всегда вызывался бы метод `Animal::sound()`.

## 4. Чисто виртуальные функции (Pure Virtual Functions)

> Чисто виртуальная функция - это виртуальная функция, после декларации которой написали = 0

Синтаксис:
`virtual void functionName() = 0;`

Класс, содержащий хотя бы одну чисто виртуальную функцию, называется **абстрактным классом** (abstract class). Экземпляры абстрактных классов **нельзя** создавать напрямую. Такой класс обычно служит «интерфейсом» или базой для наследования.

[Пример]

```cpp
class Shape {
public:
    virtual void draw() = 0; // чисто виртуальная функция
    virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing Circle\n";
    }
};

class Square : public Shape {
public:
    void draw() override {
        std::cout << "Drawing Square\n";
    }
};

int main() {
    // Shape s; // Ошибка: класс Shape — абстрактный, нельзя создавать объекты
    Shape* c = new Circle();
    Shape* sq = new Square();

    c->draw();   // Drawing Circle
    sq->draw();  // Drawing Square

    delete c;
    delete sq;
    return 0;
}

```

Чисто виртуальный метод `draw()` заставляет **каждый** производный класс **обязательно** предоставлять свою реализацию.

### Чисто виртуальный деструктор

Иногда делают и деструктор чисто виртуальным:

```cpp
class AbstractBase {
public:
    virtual ~AbstractBase() = 0; // объявляем как чисто виртуальный
};

inline AbstractBase::~AbstractBase() {
    // даже для чисто виртуального деструктора нужно тело
}

```

Зачем? Чтобы класс нельзя было инстанциировать, но при этом чтобы деструктор оставался виртуальным (для корректного удаления производных).

## 5. Виртуальные деструкторы (Virtual Destructors)

### Зачем нужны?

Если класс содержит хотя бы одну виртуальную функцию (или предполагается использовать полиморфизм), **настойчиво рекомендуется** объявлять деструктор виртуальным. Иначе при удалении объекта производного класса через указатель базового типа может не вызваться деструктор производного класса, что часто приводит к утечкам ресурсов.

[Пример]

```cpp
#include <iostream>

class Base {
public:
    virtual ~Base() {
        std::cout << "Base destructor\n";
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor\n";
    }
};

int main() {
    Base* obj = new Derived();
    delete obj;  // сначала ~Derived(), потом ~Base()
    return 0;
}

```

Вывод:
`Derived destructor Base destructor`

Если убрать `virtual` у деструктора `Base`, то при `delete obj` вызвался бы _только_ `~Base()`, а `~Derived()` — _нет_, что привело бы к утечкам или некорректному освобождению.

## 6. Обработка исключений (Exception Handling)

> **Исключения** — это механизм языка, позволяющий «выбрасывать» (throw) и «ловить» (catch) ошибки, которые могут возникнуть в программе. В С++ он позволяет отделить _логику обработки ошибок_ от _основного потока кода_.

**Синтаксис:**

```cpp
try {
    // Блок кода, где может произойти ошибка
    // ...
    throw std::runtime_error("Some error"); 
} 
catch (const std::exception& e) {
    // Блок, который перехватывает исключения типа std::exception и его наследников
    std::cerr << "Exception: " << e.what() << std::endl;
}
catch (...) {
    // "Поймать всё" — ловит исключения любого типа
    std::cerr << "Unknown exception caught!\n";
}

```

[Пример]

```cpp
#include <iostream>
#include <stdexcept>

int divide(int a, int b) {
    if (b == 0) {
        throw std::runtime_error("Division by zero");
    }
    return a / b;
}

int main() {
    try {
        std::cout << divide(10, 2) << std::endl;  // 5
        std::cout << divide(10, 0) << std::endl;  // исключение!
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}

```

- При вызове `divide(10, 0)` генерируется исключение `std::runtime_error`, которое перехватывается блоком `catch (const std::exception& e)`.
- `what()` — это метод, определённый в классе `std::exception` (и его производных) в C++. Он используется для получения текста сообщения об исключении в виде строки.

### Дополнительные моменты

- **Стек раскручивается** (stack unwinding) — объекты локальных переменных уничтожаются по пути выхода из функции, где возникло исключение.
- Можно объявлять и _свои_ классы исключений, например, наследуясь от `std::exception`.
- Ключевое слово `noexcept` в современном C++ указывает, что функция _не_ будет выбрасывать исключения. При нарушении этого обещания программа обычно завершается (`std::terminate).
- В _конструкторах_ исключения разрешены, но нужно аккуратно продумать последствия. В _деструкторах_ бросать исключения крайне не рекомендуется (если при разрушении объекта выбросится исключение, а одновременно выбросится ещё одно исключение из другого деструктора, это приведёт к `std::terminate()`).

### Итоги

1. **Виртуальные функции** — это ключевой механизм _динамического полиморфизма_. Они позволяют определять, какая версия функции (базовая или производная) должна быть вызвана _во время выполнения_.
2. **Перегрузка (overloading)** и **переопределение (overriding)** — это разные понятия:
   - **Перегрузка**: несколько функций _в одном классе_ с одним именем и _разными параметрами_ (compile-time).
   - **Переопределение**: новая реализация виртуальной функции _в производном классе_ (runtime).
3. **Чисто виртуальные функции** превращают класс в _абстрактный_, заставляя производные классы предоставлять собственную реализацию.
4. **Виртуальный деструктор** необходим для корректного удаления объектов производных классов через указатель на базовый класс (избежание утечек и некорректного освобождения).
5. **Обработка исключений** даёт возможность отделять логику работы с ошибками от основной логики программы и обеспечивает корректное освобождение ресурсов при возникновении ошибок.
