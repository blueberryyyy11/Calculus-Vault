##### 3. Function/class templates, Basic implementation of a fixed size array in C++, destructor, copy constructor, assignment operator, private/public/protected, classes, class vs struct, const member functions.

# 1. Basic implementation of a fixed size array in C++

FixedSizeArray.h
```cpp
  1. #pragma once
  2. #include <cstddef>
  3. 
  4. /*
  5. ----------->[ВОПРОС] Чем отличается класс от структуры?
  6. Ответ: Класс отличается от структуры лишь двумя вещами.
  7. 1. Все мемберы класса (как переменные так и функции) в структуре доступны
  8. повсеместно если ничего другого не писать (все public). В классе наоборот - все мемберы класса
  9. не доступны никому если ничего другого не писать (все private).
 10. 2. Тип наследования от структуры - public, а тип наследования от класса - private (в этих файлах это не используется).
 11. 
 12. Интерфейс - всё то, что позволяет общаться с классом вне самого класса
 13. (для нижеопределенного класса - это функции, объявленные под public:)
 14. 
 15. Хорошей практикой является декларировать мембер функции в одном файле, а имплементировать в другом (Interface Segregation Principle).
 16. В данном файле написаны лишь декларации упомянутых функций, их имплементация может быть найдена в файле FixedSizeArray.cpp.
 17. */
 18. class FixedSizeArray
 19. {
 20. 
 21. /*
 22. Если написать внутри класса ключевое слово private: тогда то, что окажется под этим модификатором
 23. доступа станет недоступным нигде, кроме самого класса. Если же писать модификатор доступа public:
 24. то всё то, что под ним окажется станет доступным.
 25. 
 26. Данный класс обладает двумя переменными - m_arr и m_size с модификатором доступа private, а также
 27. функциями size, operator[], конструкторами и деструктором с модификатором доступа public.
 28. */
 29. private:
 30.    int* m_arr;
 31.    std::size_t m_size;
 32. /*
 33.    ----------->[ВОПРОС] Почему m_arr и m_size в private?
 34.    Ответ: Так как объект данного класса из себя должен представлять массив фиксированной длины (FixedSizeArray),
 35.    следовательно размер массива на который указывает m_arr должен равнятся значению m_size всегда и повсюду.
 36.    Следовательно мы не хотим, чтобы у человека, который будет использовать наш класс в своих грязных целях
 37.    даже появилась бы мысль поменять значение m_arr или m_size, a даже если бы и появилась бы - то он не смог.
 38. 
 39.    В общем и целом - модификаторы доступа нужны, чтобы в самом классе не появлялось бы внутренних противоречий.
 40. 
 41.    ----------->[ВОПРОС] Почему у m_size тип std::size_t?
 42.    Ответ: std::size_t определен в заголовочном файле <cstddef> и представляет из себя неотрицательный целочисленный
 43.    тип, который способен в себе хранить наибольший размер куска памяти, который поддерживается самой системой.
 44.    В 32-битной системе размер std::size_t 32 бита, а в 64-битной системе размер std::size_t 64 бита.
 45.    Его будем использовать для размеров, индексов и количества.
 46. */
 47. 
 48. public:
 49.    /* Конструкторы (Если непонятно - посмотри "Struct + operators.cpp" конструкторы)
 50. 
 51.    FixedSizeArray(std::size_t size); - Принимает size и создает массив размера size, элементы которых неинициализованны․
 52. 
 53.    FixedSizeArray(std::size_t size, int val); - Принимает size, val и создает массив размера size где каждый элемент равен val․
 54.    */
 55.    FixedSizeArray(std::size_t size);
 56. 
 57.    FixedSizeArray(std::size_t size, int val);
 58. 
 59.    /* std::size_t size() const;
 60. 
 61.    Хоть мы и не хотим, чтобы юзер мог бы изменять значения наших мембер филдов - мы не имеем право не дать
 62.    ему каким-то образом получить, ну, хотя бы размер массива, с которым он работает, поэтому логично было бы
 63.    создать функцию, которая возвращала бы размер массива. Для этого служит функция size().
 64.    Замечание: Если непонятно, почему написано const справа от функции - посмотри файл "Struct + operators.cpp" (функция abs)
 65.    */
 66.    std::size_t size() const;
 67. 
 68.    /* int& operator[](std::size_t index);
 69. 
 70.    Если не знаешь, что такое перегрузка операторов -
 71.    посмотри файл "Struct + operators.cpp" (функции operator+=, -=, *=, /=, +, -, *, /, <<).
 72. 
 73.    operator[] служит для того, чтобы обратиться к элементу массива через определенный индекс.
 74.    Например:
 75. 
 76.    int main()
 77.    {
 78.       FixedSizeArray fsArr(10, -3); // Создает массив размера 10, каждый элемент которого равен -3.
 79. 
 80.       std::cout << fsArr;
 81.       return 0;
 82.    }
 83. */
 84.    ----------->[ВОПРОС] Почему operator[] возвращает референс?
 85.    Ответ: Если бы operator[] возвращал бы просто int, т.е. имел бы вид
 86. 
 87.    int operator[](std::size_t index);
 88. 
 89.    Тогда нельзя было бы писать
 90.    int main()
 91.    {
 92.       FixedSizeArray fsArr(10, -3); // Создает массив размера 10, каждый элемент которого равен -3.
 93. 
 94.       fsArr = -11; 
 95.                       // который бы вернул r-value значение, а оно не может быть слева от знака равно => Compile error.
 96.       return 0;
 97.    }
 98. 
 99.    Если же operator[] возвращает референс, то на 94-eй строке operator[] вернет l-value значение,
100.    что позволит поменять значение элемента массива с индексом 4 на -11.
101. 
102.    ----------->[ВОПРОС] Почему этот operator[] не const?
103.    Ответ: Если бы мы написали
104. 
105.    int& operator[](std::size_t index) const;
106. 
107.    Тогда можно было бы менять элементы массива с константного объекта, т.е. например:
108. 
109.    int main()
110.    {
111.       const FixedSizeArray fsArr(10, -3);
112. 
113.       fsArr вернет неконстантный референс
114.                       // и можно будет поменять значение элемента массива с индексом 4.
115.       return 0;
116.    }
117. 
118.    Поэтому данная функция не объявлена через const,
119.    что приведет к тому, что запись на 113ой строке просто приведет к ошибке компиляции.
120. 
121.    ----------->[Вопрос] А что если кто-нибудь захочет написать следующее?
122. 
123.    int main()
124.    {
125.       const FixedSizeArray fsArr(10, -3);
126. 
127.       std::cout << fsArr[4]; // Тут же значение fsArr[4] не меняется, а просто печатается, но так как
128.                              // будет вызван fsArr.operatorArr-константный, operator[] - не константный,
129.                              // следовательно произойдет compile error.
130.       return 0;
131.    }
132. 
133.    Ответ: Мы хотим от operator[] сразу 2 вещи
134.    1. Если operator[] вызван из неконстантного объекта, то он должен вернуть неконстантный референс.
135.    2. Если operator[] вызван из константного объекта, то он должен вернуть константный референс.
136. 
137.    Первый пункт уже готов, но на данный момент operator[] нельзя вызвать из константного объекта.
138.    Поэтому: Создаем еще один operator[], который будет вызываться из константных объектов.
139.    */
140.    int& operator[](std::size_t index);
141. 
142.    /* const int& operator[](std::size_t index) const;
143. 
144.    Нижеприведенный operator[] служит для получения значения элемента массива из константного объекта.
145.    Подытожив всё то, что было сказано, имеем следующее:
146. 
147.    int main()
148.    {
149.       FixedSizeArray fsArr1(10, -3);        // Неконстантный объект.
150.       const FixedSizeArray fsArr2(20, -5);  // Константный объект.
151. 
152.       std::cout << fsArr1[4];ределенный на строке 140.
153.                                             // Вернет int&, напечатает значение 4-го элемента, ошибки компиляции не будет.
154.       fsArr1[7] ределенный на строке 140.
155.                                             // Вернет int&, поменяет значение 7-го элемента на 100, ошибки компиляции не будет.
156.       
157.       std::cout << fsArr2[4];ределенный на строке 164.
158.                                             // Вернет const int&, напечатает значение 4-го элемента, ошибки компиляции не будет.
159.       fsArr2[7] ределенный на строке 164.
160.                                             // Вернет const int&, поменять значение элемента через константный референс не сможет, ошибка компиляции.
161.       return 0;
162.    }
163.    */
164.    const int& operator[](std::size_t index) const;
165. 
166.    /* Деструктор.
167.    
168.    ----------->[Замечание] Как известно, если что-то было объявлено при помощи new, то оно должно быть удалено при помощи delete, иначе - memory leak.
169.    ----------->[Вопрос] Переменная m_arr инициализируется в обоих конструкторах через m_arr(new int[size]), но нигде не удаляется. Что же делать?
170.    Ответ: Наряду с конструкторами, которые вызываются, когда объект только создан, есть также их антиподы - деструкторы.
171.    Они вызываются когда объект вот-вот будет удален. Например:
172. 
173.    int main()
174.    {
175.       int n;
176.       std::cin >> n;
177. 
178.       if(n%2 == 0)
179.       {
180.          FixedSizeArray fsArr(10, -4); // Создается массив в конструкторе через new.
181. 
182.          std::cout << fsArr[3];        // Делаются с массивом какие-то действия.
183.          fsArr[2] = 19;
184.       }                                // Как только мы вышли из тела if вызывается деструктор - идеальный момент, чтоб удалить m_arr.
185. 
186.       return 0;
187.    }
188. 
189.    ----------->[Синтаксис] Деструктор имеет тот же синтаксис, что и дефолтный конструктор, только с знаком ~ (тильда) в начале.
190.    ----------->[Вопрос] Может ли деструктор принимать аргументы?
191.    Ответ: нет.
192.    */
193.    ~FixedSizeArray();
194. 
195.    /* Конструктор Копирования (Copy Constructor).
196.    ----------->[Вопрос] Что будет, если данная функция отсутствует и написать нижеприведенный код?
197. 
198.    int main()
199.    {
200.       FixedSizeArray fsArr1(10, -3);
201.       FixedSizeArray fsArr2 = fsArr1;
202.       return 0;
203.    }
204.    Ответ: Ничего хорошего.
205.    Для начала поймем, что у нас на 200-ой строке создается объект нашего класса, имеющий вид
206. 
207.    _____________
208.    |  fsArr1   |
209.    -------------
210.    |           |
211.    | m_size=10 |
212.    |           |
213.    |-----------|
214.    |           |
215.    |   m_arr ------------------> [-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
216.    |           |
217.    -------------
218. 
219.    Далее, на 201-ой строке создаем объект fsArr2 на основе fsArr1 и если copy constructor отсутствует,
220.    произойдет следующее
221. 
222.    fsArr2.m_size = fsArr1.m_size;
223.    fsArr2.m_arr = fsArr1.m_arr;
224. 
225.    И наши объекты примут следующий вид
226.                             _____________
227.                             |  fsArr2   |
228.                             -------------
229.                             |           |
230.                             | m_size=10 |
231.                             |           |
232.                             |-----------|
233.                             |           |
234.                             |   m_arr   |
235.                             |     |     |
236.                             ------|------
237.    _____________                   |
238.    |  fsArr1   |                   |
239.    -------------                   |
240.    |           |                   |
241.    | m_size=10 |                   |
242.    |           |                   |
243.    |-----------|                   |
244.    |           |                   v
245.    |   m_arr ------------------> [-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
246.    |           |
247.    -------------
248. 
249.    Во-первых: Оба объекта указывают на один и тот же кусок памяти, что не есть хорошо, мы хотим скопировать наши массивы.
250.    Во-вторых: Это все UB (Undefined Behavior) так как для каждого из объектов на 202-ой строке будет вызван деструктор,
251.              что приведет к двойному удалению памяти (а это по-стандарту UB).
252. 
253.    ----------->[Вопрос] Что же делать?
254.    Ответ: Когда на строке 201 мы пишем
255.    
256.    FixedSizeArray fsArr2 = fsArr1;
257. 
258.    Вызывается copy construtor, синтаксис которого видите ниже.
259.    Данный конструктор также вызывается, если писать
260. 
261.    FixedSizeArray fsArr2(fsArr1);
262. 
263.    Или же передать объект функции по-значению, например
264. 
265.    void f(FixedSizeArray arr)
266.    {
267.       // Что-то.
268.    }
269. 
270.    int main()
271.    {
272.       FixedSizeArray fsArr(10, -20);
273. 
274.       f(fsArr); // Вызовется copy-constructor для инициализации arr на основе fsArr.
275.    }
276. 
277.    И в прочих местах где в принципе может скопироваться объект.
278.    А это идеальное место, чтобы написать как именно скопировать наш объект и чтоб строка 201 приводила бы к следующему результату.
279. 
280.                              _____________
281.                              |  fsArr2   |
282.                              -------------
283.                              |           |
284.                              | m_size=10 |
285.                              |           |
286.                              |-----------|
287.                              |           |
288.                              |   m_arr ------------------> [-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
289.                              |           |
290.                              -------------
291.    _____________
292.    |  fsArr1   |
293.    -------------
294.    |           |
295.    | m_size=10 |
296.    |           |
297.    |-----------|
298.    |           |
299.    |   m_arr ------------------> [-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
300.    |           |
301.    -------------
302. 
303.    Т.е. сделать так, чтобы вместо копирования аддресса fsArr1 в fsArr2 скопировался бы весь кусок памяти, на который ссылвается m_arr.
304.    Как именно это сделано - подробнее смотри в FixedSizeArray.cpp.
305.    */
306.    FixedSizeArray(const FixedSizeArray& other);
307. };
```

FixedSizeArray.cpp
```cpp
  1. // Для того, чтобы отделить имплементацию от декларации всю имплементацию
  2. // функций переводим в данный .cpp файл, а в .h файле пишем декларации функций.
  3. 
  4. // Сперва инклюднем .h файл, где задекларированы все функции, которые будем имплементировать. 
  5. #include "FixedSizeArray.h"
  6. 
  7. // Если декларация в классе имеет вид
  8. // 
  9. // «возвращаемый тип» «название функции»(«аргументы»);
 10. //
 11. // То в .cpp файле имплементация функции будет иметь вид
 12. //
 13. // «возвращаемый тип» «название класса»::«название функции»(«аргументы»)
 14. // {
 15. //     «тело функции»;
 16. // }
 17. //
 18. // Например, в .h файле функция size задекларирована как
 19. //
 20. // std::size_t size() const;
 21. //
 22. // а в данном файле она должа иметь нижеприведенный вид,
 23. // причем полное название функции size - это FixedSizeArray::size().
 24. std::size_t FixedSizeArray::size() const
 25. {
 26.     return m_size;
 27. }
 28. 
 29. // То, что было сказано для обычных мембер-функций верно и для конструкторов,
 30. // т.е. если конструктор задекларирован в .h файле как
 31. //
 32. // «название класса»(«аргументы»)
 33. //
 34. // то ее имплементация будет иметь вид
 35. //
 36. // «название класса»::«название класса»(«аргументы»).
 37. // 
 38. // Ниже можете видеть пример конструктора, который получает размер массива,
 39. // создает сам массив в heap-е, сохранив указатель на первый элемент m_arr,
 40. // также сохраняет значение переданного размера в m_size.
 41. FixedSizeArray::FixedSizeArray(std::size_t size)
 42.     : m_arr(new int[size])
 43.     , m_size(size)
 44. {
 45. }
 46. 
 47. // Данный же конструктор принимает 2 аргумента
 48. // 1. Размер массива
 49. // 2. Значение, которым надо заполнить все элементы массива
 50. // Делает данный конструктор то же самое, что и верхний конструктор,
 51. // просто дополнительно проходит по всем элементам созданного массива и 
 52. // приравнивает к каждому элементу переданное значение val.
 53. FixedSizeArray::FixedSizeArray(std::size_t size, int val)
 54.     : m_arr(new int[size])
 55.     , m_size(size)
 56. {
 57.     for (std::size_t i = 0; i < size; ++i)
 58.     {
 59.         m_arr[i] = val;
 60.     }
 61. }
 62. 
 63. // О данных двух функциях уже было сказано в .h файле.
 64. // Они просто возвращают референс на элемент массива соответствующий индексу.
 65. int& FixedSizeArray::operator[](std::size_t index)
 66. {
 67.     return m_arr[index];
 68. }
 69. 
 70. const int& FixedSizeArray::operator[](std::size_t index) const
 71. {
 72.     return m_arr[index];
 73. }
 74. 
 75. // В деструкторе просто удаляем массив, на который указывает m_arr.
 76. FixedSizeArray::~FixedSizeArray()
 77. {
 78.     delete[] m_arr;
 79. }
 80. 
 81. // В конструкторе копирования создается новый массив того же размера, что и
 82. // массив переданного объекта other, после чего копируется содержание массива other.m_arr
 83. // в m_arr.
 84. FixedSizeArray::FixedSizeArray(const FixedSizeArray& other)
 85.     : m_arr(new int[other.m_size])
 86.     , m_size(other.m_size)
 87. {
 88.     for (std::size_t i = 0; i < m_size; ++i)
 89.     {
 90.         m_arr[i] = other[i];
 91.     }
 92. }
```


# 2. Function/class templates

TemplateFixedSizeArray.h
```cpp
  1. #pragma once
  2. #include <cstddef>
  3. #include <iostream>
  4. #include <string>
  5. 
  6. // В данном файле объясняются
  7. // 1. Функции template
  8. // 2. Классы template
  9. // 3. Отделение интерфейса от реализации для темплейт классов
 10. // 4. Реализация мув конструктора и оператора присваивания
 11. 
 12. // Допустим мы хотим создать функцию, которая печатает переданное значение.
 13. // Пример:
 14. void print(int x)
 15. {
 16.    std::cout << x << "\n";
 17. }
 18. // Отлично! При вызове print(777); будет напечатано 777, но что если надо также уметь печатать строки?
 19. // Разумеется если сейчас вызвать print("Hello World!"); будет ошибка компиляции. Поэтому мы решаем использовать
 20. // перегрузку функций.
 21. void print(std::string str)
 22. {
 23.    std::cout << str << "\n";
 24. }
 25. // Теперь если вызвать print(777); вызовется первая функция, а если вызвать print("Hello World!"); вторая.
 26. // Но что если мы попытаемся вызвать print('c'); ? Ведь 'c' char и для этого типа нет соответствующей функции.
 27. // Вот мы и создаем еще одну функцию
 28. void print(char c)
 29. {
 30.    std::cout << c << "\n";
 31. }
 32. 
 33. // --------> [ВОПРОС] Для каких еще типов надо определить данную функцию?
 34. // Ответ: Как раз для таких случаев и созданы функции-шаблоны (function templates).
 35. // Синтаксис определения функции-шаблона (function template) следующий
 36. //
 37. // template <typename «Название Типа» >
 38. // «определение функции»
 39. //
 40. // Например:
 41. //
 42. // template <typename T>
 43. // void print(T value)
 44. // {
 45. //    std::cout << value << "\n";
 46. // }
 47. //
 48. // Но данную функцию можно улучшить, так как нам ненужна копия передаваемого значения для печатания
 49. // пусть функция получает данное значение по константной ссылке 
 50. template <typename T>
 51. void printValue(const T& value)
 52. {
 53.    std::cout << value << "\n";
 54. }
 55. 
 56. // В данный момент printValue не является функцией, а является шаблоном.
 57. // На его основе создаются функции.
 58. //
 59. // Например: Если вызвать где-нибудь в коде printValue(777); тогда во время компиляции автоматически будет создана функция
 60. //
 61. // void printValue(const int& value) // T=int, так как 777-это int.
 62. // {
 63. //    std::cout << value << "\n";
 64. // }
 65. //
 66. // А если вызвать где-нибудь еще printValue("Hello World!") тогда также будет создана функция
 67. //
 68. // void printValue(const char*& value) // T=char*, так как тип "Hello World!" - это char*
 69. // {
 70. //     std::cout << value << "\n";
 71. // }
 72. // 
 73. // Замечание: Если же еще где-то вызвана функция printValue(12345); новой функции создано не будет, а будет вызвана
 74. //            функция созданная на строке 61.
 75. //
 76. // Созданные функции называются template functions.
 77. // Подытожим: То что было создано на строке 51 называется function template, и это не функции, а шаблоны,
 78. //            а то, что было создано на строках 61 и 68 - template function, и это уже функции.
 79. // 
 80. // -------->[ВОПРОС] А что если мы хотим передать "Hello World" не как char*, а как std::string?
 81. // Ответ: Вот функция, в которой передает "Hello World" как строку функции printValue несколькими способами
 82. void pass_hello_world_as_string()
 83. {
 84.    // -------------->[СПОСОБ 1]
 85.    std::string str{"Hello World"}; // Напрямую создать std::string и передать.
 86.    printValue(str);
 87. 
 88.    // -------------->[СПОСОБ 2]
 89.    printValue<std::string>("Hello World"); // Тут значение T в printValue вручную определяется как T=std::string.
 90.    // Подробно: На самом деле название фенерируемой функции не просто printValue, а printValue<T>
 91.    //           Вызывая printValue<std::string>, мы как-бы вручную говорим, что T=std::string и не позволяем
 92.    //           компилятору дедуцировать тип "Hello World" как char*, а заставляем сгенерировать функцию
 93.    // 
 94.    //           void printValue(const std::string& value);
 95.    //
 96.    //           И сконвертировать "Hello World" в std::string.
 97. 
 98. 
 99.    // -------------->[СПОСОБ 3]
100.    // Использовать std::string_literals. Делается это так:
101.    using namespace std::string_literals; // После данной комманды, если написать s после ковычек, тогда тип текста
102.                                          // в ковычках уже будет не типа char*, а будет типа std::string.
103.    printValue("Hello World"s); // Заметим, что после "Hello World" написано s, значит будет иметь тип std::string.
104. }
105. 
106. // В FixedSizeArray.h мы объявили массив типа int. Но что если мы хотим уметь создавать массивы любых типов?
107. // Для такого случая и созданы классы-шаблоны (class templates). Определяются они почти тем же способом
108. // как и функции-шаблоны.
109. 
110. // template <typename «Название Типа» >
111. // «определение класса»
112. template <typename T>
113. class FixedSizeArray
114. {
115. private:
116.    T* m_arr;           
117.    std::size_t m_size;
118.    // Тут вместо int* m_arr; напишем T* m_arr; таким образом будем хранить тот тип данных,
119.    // который и был определен для нашего объекта. А определяется он следующим образом:
120.    //
121.    // int main()
122.    // {
123.    //    FixedSizeArray<double> arr1(10); // Тут T=double, и m_arr будет указателем на массив из double-ов.
124.    //    FixedSizeArray<std::string> arr2(77); // Тут T=std::string, и m_arr будет указателем на массив строк.
125.    // }
126.    //
127.    // По аналогии с функциями: FixedSizeArray - это class template,
128.    // a FixedSizeArray<double> и FixedSizeArray<std::string> - это template classes.
129.    // И для каждого типа генерируется свой собственный отдельный класс.
130. 
131. public:
132.    // Далее - повсюду вместо типа int напишем T.
133. 
134.    //---Старые функции, которые были определены в FixedSizedArray.h-
135. 
136.    FixedSizeArray(std::size_t size);
137. 
138.    FixedSizeArray(std::size_t size, T val);
139. 
140.    std::size_t size() const;
141. 
142.    T& operator[](std::size_t index);
143. 
144.    const T& operator[](std::size_t index) const;
145. 
146.    ~FixedSizeArray();
147. 
148.    FixedSizeArray(const FixedSizeArray& other);
149. 
150.    //----Функции, неопределенные в FixedSizedArray.h----------------
151. 
152.    // move constructor (Подробно смотри в MoveSemantics.cpp, тут же смотри имплементацию)
153.    FixedSizeArray(FixedSizeArray&& other);
154. 
155.    // FixedSizeArray& operator=(const FixedSizeArray& other);
156.    // 
157.    // Как мы уже знаем, если написать
158.    //
159.    // int main()
160.    // {
161.    //    FixedSizeArray<int> fsArr1(10, 2);
162.    //    FixedSizeArray<int> fsArr2 = fsArr1;
163.    // }
164.    // 
165.    // то на 162ой строке будет вызван copy-конструктор, определенный на строке 148.
166.    // Что же происходит, если написать
167.    // 
168.    // int main()
169.    // {
170.    //    FixedSizeArray<int> fsArr1(10, 2);
171.    //    FixedSizeArray<int> fsArr2(7);
172.    // 
173.    //    fsArr2 = fsArr1;
174.    // }
175.    // 
176.    // Поймем, что на 173-ей строке copy-конструктор не вызывается, так как fsArr2 уже создан на строке 171.
177.    // Ну как мы уже знаем, для бинарных действий вызывается соответствующий оператор, в данном случае - operator=.
178.    // Вызов имеет вид fsArr2.operator=(fsArr1); если данный оператор будет отсутствовать, то компилятор
179.    // сгенерирует свой собственный operator=, который будет делать следующее
180.    //
181.    // FixedSizeArray& operator=(const FixedSizeArray& other)
182.    // {
183.    //    m_arr = other.m_arr;
184.    //    m_size = other.m_size;
185.    // 
186.    //    return *this;
187.    // }
188.    //
189.    // Тут 183-ая строка приведет к той ситуации, которую мы видели на строках 196-253 в FixedSizeArray.h,
190.    // Если коротко - fsArr1 и fsArr2 будут показывать на тот же кусок памяти, что приведет к двойному
191.    // удалению одной и той же памяти при вызове деструкторов, а это undefined behavior.
192.    // Именно поэтому мы создаем собственный operator=, где копируем не указатель m_arr, а сам массив (смотри реализацию ниже).
193.    //
194.    // -------->[ВОПРОС] Что такое this?
195.    // Ответ: this - это указатель на объект, для которого был вызван сам метод.
196.    // Например, если рассмотреть вызов operator= на строке 173, который из себя представляет fsArr2.operator=(fsArr1);
197.    // то внутри operator= this будет указывать на fsArr2, а *this будет референсом на fsArr2, other - референс на fsArr1.
198.    //
199.    // -------->[ВОПРОС] Зачем operator= возвращает *this?
200.    // Ответ: Для ответа на этот вопрос рассмотрим следующий код
201.    // 
202.    // int main()
203.    // {
204.    //    int x = 10;
205.    //    int y = 20;
206.    //    int z = 30;
207.    // 
208.    //    (x = y) = z;
209.    //    
210.    //    std::cout << x << " " << y << " " << z;
211.    // }
212.    //
213.    // Как уже было сказано в References.cpp - всякое выражение в C++ имеет тип, значение и побочный эффект.
214.    // Тип x=y: int&
215.    // значение: референс на х
216.    // побочный эффект: приравнять y к х.
217.    //
218.    // Подытожив: x=y приравняет y к х, но само это выражение есть референс на х, следовательно после к х будет присвоено значение z.
219.    // а на 208ой строке будет напечатано "30 20 30".
220.    //
221.    // Именно поэтому operator= возвращает референс на объект слева от знака =.
222.    //
223.    // кроме этого, если рассмотреть код
224.    // int main()
225.    // {
226.    //    int x = 10;
227.    //    int y = 20;
228.    //    int z = 30;
229.    // 
230.    //    x = y = z;
231.    //    
232.    //    std::cout << x << " " << y << " " << z;
233.    // }
234.    //
235.    // тут на 228ой стрике скобки отсутствуют операции пройдут справа налево, т.е.
236.    // 1. к y будет присвоено значение z,
237.    // 2. к х будет присвоено значение y.
238.    //
239.    // Замечание1: Операция равенства единственная бинарная операция, которая происходит справа налево.
240.    // Замечание2: Всякая мембер-функция класса (в том числе конструктор и деструктор) получает в качестве аргумента this.
241.    //             В самом деле, если объект obj класса А, который имеет функцию f(int) вызывает f,
242.    //             т.е. obj.f(2), изнутри происходит A::f(&obj, 2); где &obj адресс obj, который и будет присвоен к this.
243.    FixedSizeArray& operator=(const FixedSizeArray& other);
244. 
245.    // FixedSizeArray& operator=(FixedSizeArray&& other);
246.    //
247.    // Рассмотрим следующий сценарий:
248.    //
249.    // int main()
250.    // {
251.    //    FixedSizeArray<int> fsArr1(10, 2);
252.    //    FixedSizeArray<int> fsArr2(7);
253.    //    
254.    //    // ...Какие-то действия
255.    //    // надо присвоить значение fsArr1 к fsArr2, но fsArr1 уже ненужен.
256.    //    fsArr2 = fsArr1;
257.    //    
258.    //    // ...Какие-то действия
259.    // }
260.    // 
261.    // На строке 256 будет создана копия массива fsArr1.m_arr, но старый массив уже ненужен, что делать чтоб избежать копирования?
262.    // Ответ: fsArr2 = std::move(fsArr1);
263.    // Но чтобы сам массив нескопировался бы нужно иметь move-assignment оператор, который и определен снизу.
264.    // 
265.    // Замечание: Ситуация такая же, как и при реализации move-конструктора, просто сейчас объект уже создан.
266.    FixedSizeArray& operator=(FixedSizeArray&& other);
267. };
268. 
269. // Сперва поговорим про отделении реализации мембер функций от их декларации на примере функции size().
270. // На самом деле полное название функции size() - это FixedSizeArray<T>::size(), где T - это тип, определенный
271. // на строке 112 и данный тип работает только в данном классе (заметте, что внутри класса название класса
272. // записывается как FixedSizeArray, а не FixedSizeArray<T>, так как компилятор понимает, что внутри класса - это одно и то же).
273. //
274. // Но для того чтобы реализовать функцию вне класса, надо объявить template <typename T> (или вместо Т другую букву, разницы нет)
275. // и писать полное имя данного класса. Также было сделано и в FixedSizeArray.h и в FixedSizeArray.cpp, но тогда
276. // данный класс не был шаблонным, и мы спокойно писали FixedSizeArray::size().
277. //
278. // ------->[ВОПРОС] В FixedSizeArray.h и FixedSizeArray.cpp мы декларировали функции в .h файле, а реализовывали в .cpp, почему сейчас всё в .h файле?
279. // Ответ: Не можем отделить. Если попытаться отделить реализации функций в отдельный .cpp файл, данный .cpp будет скомпилирован
280. // лишь единожды отдельно от остальных .cpp файлов, и в момент компиляции будет непонятно, для каких типов
281. // генерировать определенные функции. А если все писать в .h файле, такой проблемы не возникнет.
282. template <typename T>
283. std::size_t FixedSizeArray<T>::size() const
284. {
285.    return m_size;
286. }
287. 
288. // Далее рассмотрим мув конструктор
289. //
290. // Как можем видеть, тут просто копируются поля данных классов, и к other.m_arr приравнивается nullptr.
291. // Всё так, как уже было объяснено в MoveSemantics.cpp в строках 70-94.
292. template <typename T>
293. FixedSizeArray<T>::FixedSizeArray(FixedSizeArray&& other)
294.    : m_arr(other.m_arr)
295.    , m_size(other.m_size)
296. {
297.    other.m_arr = nullptr;
298. }
299. 
300. // Рассмотрим assignment operator
301. template <typename T>
302. FixedSizeArray<T>& FixedSizeArray<T>::operator=(const FixedSizeArray<T>& other)
303. {
304.    // Сперва проверяется, может объект был приравнен к самому себе, как например
305.    //
306.    // FixedSizeArray<int> fsArr(10, -5);
307.    // fsArr = fsArr;
308.    //
309.    // И если так, то ничего делать не надо, просто возвращаем *this.
310.    if (this == &other)
311.       return *this;
312.    ~FixedSizeArray<T>(); // Далее стирается массив объекта слева от знака равно при помощи вызова деструктора.
313. 
314.    // Как уже было сказано: this - это указатель на объект, для которого был вызван данный метод.
315.    // Пусть ptr - указатель на объект класса, у которого есть мембер-переменная val, тогда
316.    // запись ptr->val эквивалентна записи (*ptr).val. То есть если хотим обратиться к переменной val
317.    // через указатель, вместо точки используем стрелку ->.
318.    // Точно так же с функциями: если ptr - указатель на объект класса, у которого есть мембер-функция f(), тогда
319.    // её можно вызвать через указатель, если написать ptr->f().
320.    // Снизу запись this->m_arr и this->m_size абсолютно эквивалентны записям m_arr и m_size. Написано всё так
321.    // чисто ради иллюстрации ключевого слова this и операции стрелочки.
322.    this->m_arr = new T[other.m_size]{}; // создается новый массив.
323.    for (std::size_t i = 0; i < other.m_size; ++i)
324.    {
325.       this->m_arr[i] = other.m_arr[i]; // каждый элемент массива other копируется в массив this.
326.    }
327.    this->m_size = other.m_size; // копируется size.
328. 
329.    return *this; // возвращается объект данного класса.
330. }
331. 
332. // Рассмотрим move-assignment operator
333. template <typename T>
334. FixedSizeArray<T>& FixedSizeArray<T>::operator=(FixedSizeArray<T>&& other)
335. {
336.    // Начинается всё так же, как и в assignment операторе.
337.    if (this == &other)
338.       return *this;
339.    ~FixedSizeArray<T>();
340. 
341.    // Далее копируется адрес на массив объекта other.
342.    this->m_arr = other.m_arr;
343.    // Адрес объекта other стирается, чтобы не происходило бы двойного удаления.
344.    other.m_arr = nullptr;
345.    // Копируется размер.
346.    this->m_size = other.m_size;
347. 
348.    // Возвращается референс на объект слева от знака =.
349.    return *this;
350. }
351. 
352. // Также рассмотрим деструктор
353. template <typename T>
354. FixedSizeArray<T>::~FixedSizeArray()
355. {
356.    // ------->[ВОПРОС] A не нужно ли проверять, является ли m_arr пустым при удалении? Ведь на 344-й строке
357.    //                  указатель m_arr приравнивается к nullptr.
358.    // Ответ: Не нужно. Всё из-за того, что в стандарте C++ указано, что использование команды delete или delete[] на указателе,
359.    //        который указывает на nullptr, является безопасной операцией и просто ничего не делает.
360.    delete[] m_arr;
361. }
362. 
363. template <typename T>
364. FixedSizeArray<T>::FixedSizeArray(std::size_t size)
365.    : m_arr(new T[size]{})
366.    , m_size(size)
367. {
368. }
369. 
370. template <typename T>
371. FixedSizeArray<T>::FixedSizeArray(std::size_t size, T val)
372.    : m_arr(new T[size])
373.    , m_size(size)
374. {
375.    for (std::size_t i = 0; i < size; ++i)
376.    {
377.       m_arr[i] = val;
378.    }
379. }
380. 
381. template <typename T>
382. FixedSizeArray<T>::FixedSizeArray(const FixedSizeArray& other)
383.    : m_arr(new T[other.m_size])
384.    , m_size(other.m_size)
385. {
386.    for (std::size_t i = 0; i < m_size; ++i)
387.    {
388.       m_arr[i] = other[i];
389.    }
390. }
391. 
392. template <typename T>
393. T& FixedSizeArray<T>::operator[](std::size_t index)
394. {
395.    return m_arr[index];
396. }
397. 
398. template <typename T>
399. const T& FixedSizeArray<T>::operator[](std::size_t index) const
400. {
401.    return m_arr[index];
402. }
```

